THERE_BE_DRAGONS_HERE
Halt
25 June 2018 3:53:28.612504 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

PRBookTesterTest(Object)>>halt
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest>>testEvaluateClassCreation
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		cb: 	a PRCodeblock[97006080] text: 'PRBookTesterTest subclass: #PRBookTesterTest...etc...
		bTester: 	a PRBookTesterVisitor
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest(TestCase)>>performTest
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ self setUp.
self performTest ] in PRBookTesterTest(TestCase)>>runCase
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PRBookTesterTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PRBookTesterTest(TestCase)>>runCase
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


PRBookTesterTest(TestCase)>>runCaseManaged
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		timeStamp: 	2018-06-25T15:53:28.584265+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	78
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		timeStamp: 	2018-06-25T15:53:28.584265+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in PRBookTesterTest(TestCase)>>debug
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PRBookTesterTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


PRBookTesterTest(TestCase)>>debug
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest class(TestCase class)>>debug:
	Receiver: PRBookTesterTest
	Arguments and temporary variables: 
		aSymbol: 	#testEvaluateClassCreation
	Receiver's instance variables: 
		superclass: 	PRBookTestEnvironment
		methodDict: 	a MethodDictionary(#setUp->PRBookTesterTest>>#setUp #testEvaluateCl...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PRBookTesterTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Pillar-BookTester'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testEvaluateClassCreat...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testEvaluateClassCreation
		testClass: 	PRBookTesterTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEvaluateClassCreation)
		testSelector: 	#testEvaluateClassCreation
		each: 	PRBookTesterTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(PRBookTesterTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	3
		each: 	PRBookTesterTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. PRBookTesterTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEvaluateClassCreation)
		testSelector: 	#testEvaluateClassCreation
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testEvaluateClassCreation)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testEvaluateClassCreation))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testEvaluateClassCreation))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(500993536)
		selectedItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
PRBookTesterTest(Object)>>halt
PRBookTesterTest>>testEvaluateClassCreation
PRBookTesterTest(TestCase)>>performTest
[ self setUp.
self performTest ] in PRBookTesterTest(TestCase)>>runCase
BlockClosure>>ensure:
PRBookTesterTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
PRBookTesterTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in PRBookTesterTest(TestCase)>>debug
BlockClosure>>ensure:
PRBookTesterTest(TestCase)>>debug
PRBookTesterTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ target perform: actionSelector withArguments: arguments ] in IconicButton(SimpleButtonMorph)>>doButtonAction
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButton(SimpleButtonMorph)>>doButtonAction
IconicButton(SimpleButtonMorph)>>mouseUp:
IconicButton(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButton(Morph)>>handleEvent:
IconicButton(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Halt
25 June 2018 4:06:41.327146 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

PRBookTesterTest(Object)>>halt
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest>>testEvaluateClassCreation
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		cb: 	a PRCodeblock[499188224] text: 'PRBookTesterTest subclass: #PRBookTesterTes...etc...
		bTester: 	a PRBookTesterVisitor
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest(TestCase)>>performTest
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ self setUp.
self performTest ] in PRBookTesterTest(TestCase)>>runCase
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PRBookTesterTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PRBookTesterTest(TestCase)>>runCase
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


PRBookTesterTest(TestCase)>>runCaseManaged
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		timeStamp: 	2018-06-25T16:06:41.314239+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	78
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		timeStamp: 	2018-06-25T16:06:41.314239+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in PRBookTesterTest(TestCase)>>debug
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PRBookTesterTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


PRBookTesterTest(TestCase)>>debug
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		result: 	0 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest class(TestCase class)>>debug:
	Receiver: PRBookTesterTest
	Arguments and temporary variables: 
		aSymbol: 	#testEvaluateClassCreation
	Receiver's instance variables: 
		superclass: 	PRBookTestEnvironment
		methodDict: 	a MethodDictionary(#setUp->PRBookTesterTest>>#setUp #testEvaluateCl...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PRBookTesterTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Pillar-BookTester'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testEvaluateClassCreat...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testEvaluateClassCreation
		testClass: 	PRBookTesterTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEvaluateClassCreation)
		testSelector: 	#testEvaluateClassCreation
		each: 	PRBookTesterTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(PRBookTesterTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	3
		each: 	PRBookTesterTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. PRBookTesterTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEvaluateClassCreation)
		testSelector: 	#testEvaluateClassCreation
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testEvaluateClassCreation)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testEvaluateClassCreation))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testEvaluateClassCreation))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(500993536)
		selectedItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
PRBookTesterTest(Object)>>halt
PRBookTesterTest>>testEvaluateClassCreation
PRBookTesterTest(TestCase)>>performTest
[ self setUp.
self performTest ] in PRBookTesterTest(TestCase)>>runCase
BlockClosure>>ensure:
PRBookTesterTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
PRBookTesterTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in PRBookTesterTest(TestCase)>>debug
BlockClosure>>ensure:
PRBookTesterTest(TestCase)>>debug
PRBookTesterTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ target perform: actionSelector withArguments: arguments ] in IconicButton(SimpleButtonMorph)>>doButtonAction
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButton(SimpleButtonMorph)>>doButtonAction
IconicButton(SimpleButtonMorph)>>mouseUp:
IconicButton(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButton(Morph)>>handleEvent:
IconicButton(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
25 June 2018 4:18:18.183781 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

PRBookTesterTest(TestAsserter)>>assert:
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest>>testEvaluateClassCreation
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		bTester: 	a PRBookTesterVisitor
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest(TestCase)>>performTest
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ self setUp.
self performTest ] in PRBookTesterTest(TestCase)>>runCase
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PRBookTesterTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PRBookTesterTest(TestCase)>>runCase
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


PRBookTesterTest(TestCase)>>runCaseManaged
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		timeStamp: 	2018-06-25T16:18:18.170131+02:00
		failures: 	a Set(PRBookTesterTest>>#testEvaluateClassCreation)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	78
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		timeStamp: 	2018-06-25T16:18:18.170131+02:00
		failures: 	a Set(PRBookTesterTest>>#testEvaluateClassCreation)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in PRBookTesterTest(TestCase)>>debug
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	#()
		testingFileSystem: 	memory:///


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PRBookTesterTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


PRBookTesterTest(TestCase)>>debug
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	#()
		testingFileSystem: 	memory:///


PRBookTesterTest class(TestCase class)>>debug:
	Receiver: PRBookTesterTest
	Arguments and temporary variables: 
		aSymbol: 	#testEvaluateClassCreation
	Receiver's instance variables: 
		superclass: 	PRBookTestEnvironment
		methodDict: 	a MethodDictionary(#setUp->PRBookTesterTest>>#setUp #testEvaluateCl...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PRBookTesterTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Pillar-BookTester'
		history: 	a Dictionary(#errors->a Set() #failures->a Set() #passed->a Set(#testT...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testEvaluateClassCreation
		testClass: 	PRBookTesterTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEvaluateClassCreation)
		testSelector: 	#testEvaluateClassCreation
		each: 	PRBookTesterTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(PRBookTesterTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	3
		each: 	PRBookTesterTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. PRBookTesterTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEvaluateClassCreation)
		testSelector: 	#testEvaluateClassCreation
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testEvaluateClassCreation)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testEvaluateClassCreation))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testEvaluateClassCreation))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(500993536)
		selectedItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
PRBookTesterTest(TestAsserter)>>assert:
PRBookTesterTest>>testEvaluateClassCreation
PRBookTesterTest(TestCase)>>performTest
[ self setUp.
self performTest ] in PRBookTesterTest(TestCase)>>runCase
BlockClosure>>ensure:
PRBookTesterTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
PRBookTesterTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in PRBookTesterTest(TestCase)>>debug
BlockClosure>>ensure:
PRBookTesterTest(TestCase)>>debug
PRBookTesterTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ target perform: actionSelector withArguments: arguments ] in IconicButton(SimpleButtonMorph)>>doButtonAction
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButton(SimpleButtonMorph)>>doButtonAction
IconicButton(SimpleButtonMorph)>>mouseUp:
IconicButton(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButton(Morph)>>handleEvent:
IconicButton(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Got 7 instead of 6.
25 June 2018 4:20:00.805693 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

PRBookTesterTest(TestAsserter)>>assert:description:
	Receiver: PRBookTesterTest>>#testEverythingVirtualFileSystem
	Arguments and temporary variables: 
		aBooleanOrBlock: 	false
		aStringOrBlock: 	[ self comparingStringBetween: actual and: expected ]
		aString: 	'Got 7 instead of 6.'
	Receiver's instance variables: 
		testSelector: 	#testEverythingVirtualFileSystem
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest(TestAsserter)>>assert:equals:
	Receiver: PRBookTesterTest>>#testEverythingVirtualFileSystem
	Arguments and temporary variables: 
		actual: 	7
		expected: 	6
	Receiver's instance variables: 
		testSelector: 	#testEverythingVirtualFileSystem
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest>>testEverythingVirtualFileSystem
	Receiver: PRBookTesterTest>>#testEverythingVirtualFileSystem
	Arguments and temporary variables: 
		bTester: 	a PRBookTesterVisitor
	Receiver's instance variables: 
		testSelector: 	#testEverythingVirtualFileSystem
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest(TestCase)>>performTest
	Receiver: PRBookTesterTest>>#testEverythingVirtualFileSystem
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEverythingVirtualFileSystem
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ self setUp.
self performTest ] in PRBookTesterTest(TestCase)>>runCase
	Receiver: PRBookTesterTest>>#testEverythingVirtualFileSystem
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEverythingVirtualFileSystem
		expectedFails: 	nil
		testingFileSystem: 	memory:///


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PRBookTesterTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PRBookTesterTest(TestCase)>>runCase
	Receiver: PRBookTesterTest>>#testEverythingVirtualFileSystem
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEverythingVirtualFileSystem
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


PRBookTesterTest(TestCase)>>runCaseManaged
	Receiver: PRBookTesterTest>>#testEverythingVirtualFileSystem
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEverythingVirtualFileSystem
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
	Receiver's instance variables: 
		timeStamp: 	2018-06-25T16:20:00.769685+02:00
		failures: 	a Set(PRBookTesterTest>>#testEverythingVirtualFileSystem)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	78
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEverythingVirtualFileSystem
	Receiver's instance variables: 
		timeStamp: 	2018-06-25T16:20:00.769685+02:00
		failures: 	a Set(PRBookTesterTest>>#testEverythingVirtualFileSystem)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in PRBookTesterTest(TestCase)>>debug
	Receiver: PRBookTesterTest>>#testEverythingVirtualFileSystem
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testEverythingVirtualFileSystem
		expectedFails: 	#()
		testingFileSystem: 	memory:///


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PRBookTesterTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


PRBookTesterTest(TestCase)>>debug
	Receiver: PRBookTesterTest>>#testEverythingVirtualFileSystem
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testEverythingVirtualFileSystem
		expectedFails: 	#()
		testingFileSystem: 	memory:///


PRBookTesterTest class(TestCase class)>>debug:
	Receiver: PRBookTesterTest
	Arguments and temporary variables: 
		aSymbol: 	#testEverythingVirtualFileSystem
	Receiver's instance variables: 
		superclass: 	PRBookTestEnvironment
		methodDict: 	a MethodDictionary(#setUp->PRBookTesterTest>>#setUp #testEvaluateCl...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{PRBookTesterTestResults}
		name: 	#PRBookTesterTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Pillar-BookTester'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testEvaluateClassCreat...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testEverythingVirtualFileSystem
		testClass: 	PRBookTesterTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEverythingVirtualFileSystem))
		runTestCases: 	{PRBookTesterTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEverythingVirtualFileSystem)
		testSelector: 	#testEverythingVirtualFileSystem
		each: 	PRBookTesterTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEverythingVirtualFileSystem))
		runTestCases: 	{PRBookTesterTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(PRBookTesterTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	3
		each: 	PRBookTesterTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. PRBookTesterTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEverythingVirtualFileSystem)
		testSelector: 	#testEverythingVirtualFileSystem
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEverythingVirtualFileSystem))
		runTestCases: 	{PRBookTesterTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testEverythingVirtualFileSystem)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEverythingVirtualFileSystem))
		runTestCases: 	{PRBookTesterTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testEverythingVirtualFileSystem))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testEverythingVirtualFileSystem))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEverythingVirtualFileSystem))
		runTestCases: 	{PRBookTesterTest}



--- The full stack ---
PRBookTesterTest(TestAsserter)>>assert:description:
PRBookTesterTest(TestAsserter)>>assert:equals:
PRBookTesterTest>>testEverythingVirtualFileSystem
PRBookTesterTest(TestCase)>>performTest
[ self setUp.
self performTest ] in PRBookTesterTest(TestCase)>>runCase
BlockClosure>>ensure:
PRBookTesterTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
PRBookTesterTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in PRBookTesterTest(TestCase)>>debug
BlockClosure>>ensure:
PRBookTesterTest(TestCase)>>debug
PRBookTesterTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ target perform: actionSelector withArguments: arguments ] in IconicButton(SimpleButtonMorph)>>doButtonAction
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButton(SimpleButtonMorph)>>doButtonAction
IconicButton(SimpleButtonMorph)>>mouseUp:
IconicButton(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButton(Morph)>>handleEvent:
IconicButton(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
25 June 2018 4:20:09.547955 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

PRBookTesterTest(TestAsserter)>>assert:
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest>>testEvaluateClassCreation
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		bTester: 	a PRBookTesterVisitor
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


PRBookTesterTest(TestCase)>>performTest
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ self setUp.
self performTest ] in PRBookTesterTest(TestCase)>>runCase
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PRBookTesterTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


PRBookTesterTest(TestCase)>>runCase
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		maxTimeForTest: 	0:00:00:10
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		soleInstance: 	a CurrentExecutionEnvironment


PRBookTesterTest(TestCase)>>runCaseManaged
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	nil
		testingFileSystem: 	memory:///


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		timeStamp: 	2018-06-25T16:20:09.534181+02:00
		failures: 	a Set(PRBookTesterTest>>#testEvaluateClassCreation)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	78
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	PRBookTesterTest>>#testEvaluateClassCreation
	Receiver's instance variables: 
		timeStamp: 	2018-06-25T16:20:09.534181+02:00
		failures: 	a Set(PRBookTesterTest>>#testEvaluateClassCreation)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in PRBookTesterTest(TestCase)>>debug
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	#()
		testingFileSystem: 	memory:///


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	PRBookTesterTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


PRBookTesterTest(TestCase)>>debug
	Receiver: PRBookTesterTest>>#testEvaluateClassCreation
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testEvaluateClassCreation
		expectedFails: 	#()
		testingFileSystem: 	memory:///


PRBookTesterTest class(TestCase class)>>debug:
	Receiver: PRBookTesterTest
	Arguments and temporary variables: 
		aSymbol: 	#testEvaluateClassCreation
	Receiver's instance variables: 
		superclass: 	PRBookTestEnvironment
		methodDict: 	a MethodDictionary(#setUp->PRBookTesterTest>>#setUp #testEvaluateCl...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{PRBookTesterTestResults}
		name: 	#PRBookTesterTest
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Pillar-BookTester'
		history: 	a Dictionary(#errors->a Set() #failures->a Set(#testEvaluateClassCreat...etc...


ClyRunTestsFromMethodsCommand>>runTest:of:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testSelector: 	#testEvaluateClassCreation
		testClass: 	PRBookTesterTest
		testResult: 	nil
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEvaluateClassCreation)
		testSelector: 	#testEvaluateClassCreation
		each: 	PRBookTesterTest
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


IdentitySet(Set)>>do:
	Receiver: an IdentitySet(PRBookTesterTest)
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTest: testSelector of: each ]
		index: 	3
		each: 	PRBookTesterTest
	Receiver's instance variables: 
		tally: 	1
		array: 	{nil. nil. PRBookTesterTest. nil. nil}


ClyRunTestsFromMethodsCommand>>runTestItem:
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		testItem: 	a ClyDataSourceItem(testEvaluateClassCreation)
		testSelector: 	#testEvaluateClassCreation
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 
		each: 	a ClyDataSourceItem(testEvaluateClassCreation)
	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClyDataSourceItem(testEvaluateClassCreation))
	Arguments and temporary variables: 
		aBlock: 	[ :each | self runTestItem: each ]
		index: 	1
	Receiver's instance variables: 
an Array(a ClyDataSourceItem(testEvaluateClassCreation))

ClyRunTestsFromMethodsCommand>>execute
	Receiver: a ClyRunTestsFromMethodsCommand
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		runTestCases: 	{PRBookTesterTest}


ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
	Receiver: a ClyMethodContextOfFullBrowser
	Arguments and temporary variables: 
		aCommand: 	a ClyRunTestsFromMethodsCommand
		aCommandActivator: 	a CmdCommandActivator(a ClyRunTestsFromMethodsCommand)
	Receiver's instance variables: 
		tool: 	a ClyFullBrowser(500993536)
		selectedItems: 	an Array(a ClyDataSourceItem(testEvaluateClassCreation))
		metaLevelScope: 	ClyInstanceSideScope



--- The full stack ---
PRBookTesterTest(TestAsserter)>>assert:
PRBookTesterTest>>testEvaluateClassCreation
PRBookTesterTest(TestCase)>>performTest
[ self setUp.
self performTest ] in PRBookTesterTest(TestCase)>>runCase
BlockClosure>>ensure:
PRBookTesterTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
PRBookTesterTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
"To not affect performance of big test suites following logic is not inside addPass: method"
errors remove: aTestCase ifAbsent: [  ].
failures remove: aTestCase ifAbsent: [  ].
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in PRBookTesterTest(TestCase)>>debug
BlockClosure>>ensure:
PRBookTesterTest(TestCase)>>debug
PRBookTesterTest class(TestCase class)>>debug:
ClyRunTestsFromMethodsCommand>>runTest:of:
[ :each | self runTest: testSelector of: each ] in ClyRunTestsFromMethodsCommand>>runTestItem:
IdentitySet(Set)>>do:
ClyRunTestsFromMethodsCommand>>runTestItem:
[ :each | self runTestItem: each ] in ClyRunTestsFromMethodsCommand>>execute
Array(SequenceableCollection)>>do:
ClyRunTestsFromMethodsCommand>>execute
ClyMethodContextOfFullBrowser(ClySystemBrowserContext)>>executeCommand:by:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ target perform: actionSelector withArguments: arguments ] in IconicButton(SimpleButtonMorph)>>doButtonAction
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
IconicButton(SimpleButtonMorph)>>doButtonAction
IconicButton(SimpleButtonMorph)>>mouseUp:
IconicButton(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
IconicButton(Morph)>>handleEvent:
IconicButton(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MetacelloConflictingProjectError: Load Conflict between existing BaselineOfPillar [baseline] from gitlocal:///Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/iceberg/QDucasse/pillar/src and BaselineOfPillar [baseline] from github://QDucasse/MetacelloTestBook-Code:Chapter1
25 June 2018 4:25:31.559 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloAllowConflictingProjectUpgrade>>defaultAction
	Receiver: MetacelloAllowConflictingProjectUpgrade
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a MetacelloScriptEngine
		signalContext: 	MetacelloAllowConflictingProjectUpgrade(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		existingProjectRegistration: 	BaselineOfPillar [baseline] from gitlocal:///Users...etc...
		newProjectRegistration: 	BaselineOfPillar [baseline] from github://QDucasse/Meta...etc...


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
nil

Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		sender: 	MetacelloScriptEngine>>handleNotificationsForAction:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookup...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		sender: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupPr...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupPr...etc...


MetacelloAllowConflictingProjectUpgrade(Exception)>>pass
	Receiver: MetacelloAllowConflictingProjectUpgrade
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a MetacelloScriptEngine
		signalContext: 	MetacelloAllowConflictingProjectUpgrade(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		existingProjectRegistration: 	BaselineOfPillar [baseline] from gitlocal:///Users...etc...
		newProjectRegistration: 	BaselineOfPillar [baseline] from github://QDucasse/Meta...etc...


[ ^ exception pass ] in MetacelloScriptEngine>>handleConflict:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	#onConflict
		aBlock: 	[ ^ exception pass ]
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


MetacelloScriptEngine>>handleConflict:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


MetacelloAllowConflictingProjectUpgrade>>handleResolutionFor:
	Receiver: MetacelloAllowConflictingProjectUpgrade
	Arguments and temporary variables: 
		aScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a MetacelloScriptEngine
		signalContext: 	MetacelloAllowConflictingProjectUpgrade(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		existingProjectRegistration: 	BaselineOfPillar [baseline] from gitlocal:///Users...etc...
		newProjectRegistration: 	BaselineOfPillar [baseline] from github://QDucasse/Meta...etc...


[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
		ex: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


BlockClosure>>cull:
	Receiver: [ :ex | "option handlers need to be outermost set of handlers ... last line of defense bef...etc...
	Arguments and temporary variables: 
		anArg: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	113
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
		value: 	nil
	Receiver's instance variables: 
		sender: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProj...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProj...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		sender: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProj...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProj...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		sender: 	[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjec...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ lo...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		sender: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ load...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]


MetacelloAllowConflictingProjectUpgrade(Exception)>>signal
	Receiver: MetacelloAllowConflictingProjectUpgrade
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a MetacelloScriptEngine
		signalContext: 	MetacelloAllowConflictingProjectUpgrade(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		existingProjectRegistration: 	BaselineOfPillar [baseline] from gitlocal:///Users...etc...
		newProjectRegistration: 	BaselineOfPillar [baseline] from github://QDucasse/Meta...etc...


[ :existing :new | 
(existing hasLoadConflicts: new)
	ifTrue: [ ((existing canUpgradeTo: new)
			ifTrue: [ MetacelloAllowProjectUpgrade new ]
			ifFalse: [ (existing canDowngradeTo: new)
					ifTrue: [ MetacelloAllowProjectDowngrade new ]
					ifFalse: [ MetacelloAllowConflictingProjectUpgrade new ] ])
			existingProjectRegistration: existing;
			newProjectRegistration: new;
			signal ]
	ifFalse: [ new ] ] in MetacelloScriptEngine>>lookupProjectSpecFor:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		aProjectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloT...etc...
		registration: 	nil
		existing: 	BaselineOfPillar [baseline] from gitlocal:///Users/quentin/Documents/...etc...
		new: 	BaselineOfPillar [baseline] from github://QDucasse/MetacelloTestBook-Code:...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


[ :existing | ^ presentBlock value: existing value: newRegistration ] in MetacelloProjectRegistration class>>registrationForProjectSpec:ifAbsent:ifPresent:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		aProjectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloT...etc...
		absentBlock: 	[ :new | new ]
		presentBlock: 	[ :existing :new | 
(existing hasLoadConflicts: new)
	ifTrue: [ (...etc...
		newRegistration: 	BaselineOfPillar [baseline] from github://QDucasse/MetacelloTe...etc...
		existing: 	BaselineOfPillar [baseline] from gitlocal:///Users/quentin/Documents/...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


[ :existing | ^ presentBlock value: existing ] in MetacelloProjectRegistry>>registrationFor:ifPresent:ifAbsent:
	Receiver: a MetacelloProjectRegistry
	Arguments and temporary variables: 
		aMetacelloProjectRegistration: 	BaselineOfPillar [baseline] from github://QDucas...etc...
		presentBlock: 	[ :existing | ^ presentBlock value: existing value: newRegistrati...etc...
		absentBlock: 	[ ^ absentBlock value: newRegistration ]
		baseName: 	'Pillar'
		spec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTestBook-...etc...
		existing: 	BaselineOfPillar [baseline] from gitlocal:///Users/quentin/Documents/...etc...
	Receiver's instance variables: 
		baselineRegistry: 	a Dictionary('BaselineOfChrysal'->BaselineOfChrysal [baseline...etc...
		configurationRegistry: 	a Dictionary(#ConfigurationOfPetitParser->ConfigurationO...etc...


BlockClosure>>cull:
	Receiver: [ :existing | ^ presentBlock value: existing ]
	Arguments and temporary variables: 
		anArg: 	BaselineOfPillar [baseline] from gitlocal:///Users/quentin/Documents/Pha...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloProjectRegistry>>registrationFor:ifPresent:ifAbsent:
		startpc: 	100
		numArgs: 	1


Dictionary>>at:ifPresent:
	Receiver: a Dictionary('BaselineOfChrysal'->BaselineOfChrysal [baseline] from github://Ducasse/Chrys...etc...
	Arguments and temporary variables: 
		key: 	'BaselineOfPillar'
		aBlock: 	[ :existing | ^ presentBlock value: existing ]
		assoc: 	'BaselineOfPillar'->BaselineOfPillar [baseline] from gitlocal:///Users/q...etc...
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array('BaselineOfChrysal'->BaselineOfChrysal [baseline] from github:/...etc...


MetacelloProjectRegistry>>registrationFor:ifPresent:ifAbsent:
	Receiver: a MetacelloProjectRegistry
	Arguments and temporary variables: 
		aMetacelloProjectRegistration: 	BaselineOfPillar [baseline] from github://QDucas...etc...
		presentBlock: 	[ :existing | ^ presentBlock value: existing value: newRegistrati...etc...
		absentBlock: 	[ ^ absentBlock value: newRegistration ]
		baseName: 	'Pillar'
		spec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTestBook-...etc...
	Receiver's instance variables: 
		baselineRegistry: 	a Dictionary('BaselineOfChrysal'->BaselineOfChrysal [baseline...etc...
		configurationRegistry: 	a Dictionary(#ConfigurationOfPetitParser->ConfigurationO...etc...


MetacelloProjectRegistration class>>registrationForProjectSpec:ifAbsent:ifPresent:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		aProjectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloT...etc...
		absentBlock: 	[ :new | new ]
		presentBlock: 	[ :existing :new | 
(existing hasLoadConflicts: new)
	ifTrue: [ (...etc...
		newRegistration: 	BaselineOfPillar [baseline] from github://QDucasse/MetacelloTe...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>lookupProjectSpecFor:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		aProjectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloT...etc...
		registration: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ] in [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		version: 	nil
		loadedSpec: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgr...etc...
	Receiver's instance variables: 
		outerContext: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
...etc...
		startpc: 	142
		numArgs: 	0


[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	nil
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	repository: 'github://QDucasse/MetacelloTe...etc...
		options: 	a Dictionary()


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	THERE_BE_DRAGONS_HERE
Error: project, baseline, or configuration not specified
25 June 2018 4:25:50.672454 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloScriptApiExecutor(Object)>>error:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'project, baseline, or configuration not specified'
	Receiver's instance variables: 
		options: 	nil
		roots: 	nil
		singleRoot: 	nil
		projectSpecGenerator: 	nil
		actionArg: 	#load:->#(#())
		configurationArg: 	nil
		baselineArg: 	nil
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1'


MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>projectSpecGenerator
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 

	Receiver's instance variables: 
		options: 	nil
		roots: 	nil
		singleRoot: 	nil
		projectSpecGenerator: 	nil
		actionArg: 	#load:->#(#())
		configurationArg: 	nil
		baselineArg: 	nil
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1'


MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#repositoryArg:->#('github://QDucasse/Metacell...etc...
	Receiver's instance variables: 
		options: 	nil
		roots: 	nil
		singleRoot: 	nil
		projectSpecGenerator: 	nil
		actionArg: 	#load:->#(#())
		configurationArg: 	nil
		baselineArg: 	nil
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1'


Metacello>>execute:args:
	Receiver: a Metacello
	Arguments and temporary variables: 
		selector: 	#load:
		args: 	#(#())
		script: 	an OrderedCollection(#repositoryArg:->#('github://QDucasse/MetacelloTes...etc...
	Receiver's instance variables: 
		executorSpec: 	#MetacelloScriptApiExecutor->'batch'
		statements: 	an OrderedCollection(#repositoryArg:->#('github://QDucasse/Metacell...etc...


Metacello>>load
	Receiver: a Metacello
	Arguments and temporary variables: 

	Receiver's instance variables: 
		executorSpec: 	#MetacelloScriptApiExecutor->'batch'
		statements: 	an OrderedCollection(#repositoryArg:->#('github://QDucasse/Metacell...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Metacello new
		repository: 'github://QDucasse/MetacelloTestBook-C...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(284143872)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(284143872)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(412268288)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(284143872)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@69)
		owner: 	a TransformWithLayoutMorph(679930112)
		submorphs: 	an Array(a RubCursor(264517376) a RubPrimarySelectionMorph(460464896...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (456151808) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(825438976)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(264517376)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(27351296))
		getMenuPolicy: 	nil
		mouseDownPoint: 	(269.0@82.0)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(412268288)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(269171968) named: Pl...etc...
		lastStepTime: 	78368
		lastStepMessage: 	nil
		lastCycleTime: 	78390
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(264517376)))
		lastAlarmTime: 	78368
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(269171968) named: Pl...etc...
		lastStepTime: 	78368
		lastStepMessage: 	nil
		lastCycleTime: 	78390
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(264517376)))
		lastAlarmTime: 	78368
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(269171968) named: Pl...etc...
		lastStepTime: 	78368
		lastStepMessage: 	nil
		lastCycleTime: 	78390
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(264517376)))
		lastAlarmTime: 	78368
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(62...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
MetacelloScriptApiExecutor(Object)>>error:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>projectSpecGenerator
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
SubscriptOutOfBounds: 1
25 June 2018 4:27:51.298716 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

ByteString(Object)>>errorSubscriptBounds:
	Receiver: ''
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
''

ByteString(Object)>>at:
	Receiver: ''
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
''

ByteString>>at:
	Receiver: ''
	Arguments and temporary variables: 
		index: 	1
	Receiver's instance variables: 
''

MetacelloMCConfigurationOfProjectSpec(MetacelloProjectSpec)>>name:
	Receiver: spec 
	name: nil;.
	Arguments and temporary variables: 
		aString: 	''
	Receiver's instance variables: 
		project: 	MetacelloMCProject()
		loader: 	nil
		mutable: 	nil
		name: 	nil
		className: 	nil
		versionString: 	nil
		operator: 	nil
		loads: 	nil
		preLoadDoIt: 	nil
		postLoadDoIt: 	nil
		projectPackage: 	nil
		repositories: 	nil
		file: 	nil


MetacelloMCConfigurationOfProjectSpec(MetacelloGenericProjectSpec)>>name:
	Receiver: spec 
	name: nil;.
	Arguments and temporary variables: 
		aString: 	''
	Receiver's instance variables: 
		project: 	MetacelloMCProject()
		loader: 	nil
		mutable: 	nil
		name: 	nil
		className: 	nil
		versionString: 	nil
		operator: 	nil
		loads: 	nil
		preLoadDoIt: 	nil
		postLoadDoIt: 	nil
		projectPackage: 	nil
		repositories: 	nil
		file: 	nil


[ :projectName | {(MetacelloMCProject new configurationOfProjectSpec name: projectName)} ] in MetacelloConfigurationSpecGenerator>>projectSpecCreationBlock
	Receiver: a MetacelloConfigurationSpecGenerator
	Arguments and temporary variables: 
		projectName: 	''
	Receiver's instance variables: 
		target: 	''


MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	''
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
	Receiver's instance variables: 
		options: 	nil
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloConfigurationSpecGenerator
		actionArg: 	#load:->#(#())
		configurationArg: 	''
		baselineArg: 	nil
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1'


ByteString(String)>>execute:against:
	Receiver: ''
	Arguments and temporary variables: 
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		aScriptExecutor: 	a MetacelloScriptApiExecutor
	Receiver's instance variables: 
''

MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#configurationArg:->#('') #repositoryArg:->#('...etc...
	Receiver's instance variables: 
		options: 	nil
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloConfigurationSpecGenerator
		actionArg: 	#load:->#(#())
		configurationArg: 	''
		baselineArg: 	nil
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1'


Metacello>>execute:args:
	Receiver: a Metacello
	Arguments and temporary variables: 
		selector: 	#load:
		args: 	#(#())
		script: 	an OrderedCollection(#configurationArg:->#('') #repositoryArg:->#('gith...etc...
	Receiver's instance variables: 
		executorSpec: 	#MetacelloScriptApiExecutor->'batch'
		statements: 	an OrderedCollection(#configurationArg:->#('') #repositoryArg:->#('...etc...


Metacello>>load
	Receiver: a Metacello
	Arguments and temporary variables: 

	Receiver's instance variables: 
		executorSpec: 	#MetacelloScriptApiExecutor->'batch'
		statements: 	an OrderedCollection(#configurationArg:->#('') #repositoryArg:->#('...etc...


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Metacello new
		configuration: '';
		repository: 'github://QDucass...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(284143872)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result |  ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(284143872)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(412268288)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(284143872)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@88)
		owner: 	a TransformWithLayoutMorph(679930112)
		submorphs: 	an Array(a RubCursor(264517376) a RubPrimarySelectionMorph(460464896...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (456151808) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(825438976)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(264517376)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(257139456))
		getMenuPolicy: 	nil
		mouseDownPoint: 	(213.0@91.0)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(412268288)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(269171968) named: Pl...etc...
		lastStepTime: 	198995
		lastStepMessage: 	nil
		lastCycleTime: 	199016
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(264517376)))
		lastAlarmTime: 	198995
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(269171968) named: Pl...etc...
		lastStepTime: 	198995
		lastStepMessage: 	nil
		lastCycleTime: 	199016
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(264517376)))
		lastAlarmTime: 	198995
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a GLMSystemWindow(269171968) named: Pl...etc...
		lastStepTime: 	198995
		lastStepMessage: 	nil
		lastCycleTime: 	199016
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(264517376)))
		lastAlarmTime: 	198995
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(62...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
ByteString(Object)>>errorSubscriptBounds:
ByteString(Object)>>at:
ByteString>>at:
MetacelloMCConfigurationOfProjectSpec(MetacelloProjectSpec)>>name:
MetacelloMCConfigurationOfProjectSpec(MetacelloGenericProjectSpec)>>name:
[ :projectName | {(MetacelloMCProject new configurationOfProjectSpec name: projectName)} ] in MetacelloConfigurationSpecGenerator>>projectSpecCreationBlock
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
MetacelloConflictingProjectError: Load Conflict between existing BaselineOfPillar [baseline] from gitlocal:///Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/iceberg/QDucasse/pillar/src and ConfigurationOfPillar stable from github://QDucasse/MetacelloTestBook-Code:Chapter1
25 June 2018 4:28:06.143792 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloAllowConflictingProjectUpgrade>>defaultAction
	Receiver: MetacelloAllowConflictingProjectUpgrade
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a MetacelloScriptEngine
		signalContext: 	MetacelloAllowConflictingProjectUpgrade(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		existingProjectRegistration: 	BaselineOfPillar [baseline] from gitlocal:///Users...etc...
		newProjectRegistration: 	ConfigurationOfPillar stable from github://QDucasse/Met...etc...


UndefinedObject>>handleSignal:
	Receiver: nil
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
nil

Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		sender: 	MetacelloScriptEngine>>handleNotificationsForAction:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookup...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		sender: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupPr...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupPr...etc...


MetacelloAllowConflictingProjectUpgrade(Exception)>>pass
	Receiver: MetacelloAllowConflictingProjectUpgrade
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a MetacelloScriptEngine
		signalContext: 	MetacelloAllowConflictingProjectUpgrade(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		existingProjectRegistration: 	BaselineOfPillar [baseline] from gitlocal:///Users...etc...
		newProjectRegistration: 	ConfigurationOfPillar stable from github://QDucasse/Met...etc...


[ ^ exception pass ] in MetacelloScriptEngine>>handleConflict:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


Dictionary>>at:ifAbsent:
	Receiver: a Dictionary()
	Arguments and temporary variables: 
		key: 	#onConflict
		aBlock: 	[ ^ exception pass ]
	Receiver's instance variables: 
		tally: 	0
		array: 	#(nil nil nil nil nil)


MetacelloScriptEngine>>handleConflict:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


MetacelloAllowConflictingProjectUpgrade>>handleResolutionFor:
	Receiver: MetacelloAllowConflictingProjectUpgrade
	Arguments and temporary variables: 
		aScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a MetacelloScriptEngine
		signalContext: 	MetacelloAllowConflictingProjectUpgrade(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		existingProjectRegistration: 	BaselineOfPillar [baseline] from gitlocal:///Users...etc...
		newProjectRegistration: 	ConfigurationOfPillar stable from github://QDucasse/Met...etc...


[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
		ex: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


BlockClosure>>cull:
	Receiver: [ :ex | "option handlers need to be outermost set of handlers ... last line of defense bef...etc...
	Arguments and temporary variables: 
		anArg: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	113
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
		value: 	nil
	Receiver's instance variables: 
		sender: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProj...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProj...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		sender: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProj...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProj...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		sender: 	[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjec...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ lo...etc...


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	MetacelloAllowConflictingProjectUpgrade
	Receiver's instance variables: 
		sender: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ load...etc...
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]


MetacelloAllowConflictingProjectUpgrade(Exception)>>signal
	Receiver: MetacelloAllowConflictingProjectUpgrade
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	nil
		tag: 	nil
		signaler: 	a MetacelloScriptEngine
		signalContext: 	MetacelloAllowConflictingProjectUpgrade(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		existingProjectRegistration: 	BaselineOfPillar [baseline] from gitlocal:///Users...etc...
		newProjectRegistration: 	ConfigurationOfPillar stable from github://QDucasse/Met...etc...


[ :existing :new | 
(existing hasLoadConflicts: new)
	ifTrue: [ ((existing canUpgradeTo: new)
			ifTrue: [ MetacelloAllowProjectUpgrade new ]
			ifFalse: [ (existing canDowngradeTo: new)
					ifTrue: [ MetacelloAllowProjectDowngrade new ]
					ifFalse: [ MetacelloAllowConflictingProjectUpgrade new ] ])
			existingProjectRegistration: existing;
			newProjectRegistration: new;
			signal ]
	ifFalse: [ new ] ] in MetacelloScriptEngine>>lookupProjectSpecFor:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		aProjectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'g...etc...
		registration: 	nil
		existing: 	BaselineOfPillar [baseline] from gitlocal:///Users/quentin/Documents/...etc...
		new: 	ConfigurationOfPillar stable from github://QDucasse/MetacelloTestBook-Code...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


[ :existing | ^ presentBlock value: existing value: newRegistration ] in MetacelloProjectRegistration class>>registrationForProjectSpec:ifAbsent:ifPresent:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		aProjectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'g...etc...
		absentBlock: 	[ :new | new ]
		presentBlock: 	[ :existing :new | 
(existing hasLoadConflicts: new)
	ifTrue: [ (...etc...
		newRegistration: 	ConfigurationOfPillar stable from github://QDucasse/MetacelloT...etc...
		existing: 	BaselineOfPillar [baseline] from gitlocal:///Users/quentin/Documents/...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


[ :existing | ^ presentBlock value: existing ] in MetacelloProjectRegistry>>registrationFor:ifPresent:ifAbsent:
	Receiver: a MetacelloProjectRegistry
	Arguments and temporary variables: 
		aMetacelloProjectRegistration: 	ConfigurationOfPillar stable from github://QDuca...etc...
		presentBlock: 	[ :existing | ^ presentBlock value: existing value: newRegistrati...etc...
		absentBlock: 	[ ^ absentBlock value: newRegistration ]
		baseName: 	'Pillar'
		existing: 	BaselineOfPillar [baseline] from gitlocal:///Users/quentin/Documents/...etc...
	Receiver's instance variables: 
		baselineRegistry: 	a Dictionary('BaselineOfChrysal'->BaselineOfChrysal [baseline...etc...
		configurationRegistry: 	a Dictionary(#ConfigurationOfPetitParser->ConfigurationO...etc...


BlockClosure>>cull:
	Receiver: [ :existing | ^ presentBlock value: existing ]
	Arguments and temporary variables: 
		anArg: 	BaselineOfPillar [baseline] from gitlocal:///Users/quentin/Documents/Pha...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloProjectRegistry>>registrationFor:ifPresent:ifAbsent:
		startpc: 	132
		numArgs: 	1


Dictionary>>at:ifPresent:
	Receiver: a Dictionary('BaselineOfChrysal'->BaselineOfChrysal [baseline] from github://Ducasse/Chrys...etc...
	Arguments and temporary variables: 
		key: 	'BaselineOfPillar'
		aBlock: 	[ :existing | ^ presentBlock value: existing ]
		assoc: 	'BaselineOfPillar'->BaselineOfPillar [baseline] from gitlocal:///Users/q...etc...
	Receiver's instance variables: 
		tally: 	6
		array: 	an Array('BaselineOfChrysal'->BaselineOfChrysal [baseline] from github:/...etc...


MetacelloProjectRegistry>>registrationFor:ifPresent:ifAbsent:
	Receiver: a MetacelloProjectRegistry
	Arguments and temporary variables: 
		aMetacelloProjectRegistration: 	ConfigurationOfPillar stable from github://QDuca...etc...
		presentBlock: 	[ :existing | ^ presentBlock value: existing value: newRegistrati...etc...
		absentBlock: 	[ ^ absentBlock value: newRegistration ]
		baseName: 	'Pillar'
	Receiver's instance variables: 
		baselineRegistry: 	a Dictionary('BaselineOfChrysal'->BaselineOfChrysal [baseline...etc...
		configurationRegistry: 	a Dictionary(#ConfigurationOfPetitParser->ConfigurationO...etc...


MetacelloProjectRegistration class>>registrationForProjectSpec:ifAbsent:ifPresent:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		aProjectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'g...etc...
		absentBlock: 	[ :new | new ]
		presentBlock: 	[ :existing :new | 
(existing hasLoadConflicts: new)
	ifTrue: [ (...etc...
		newRegistration: 	ConfigurationOfPillar stable from github://QDucasse/MetacelloT...etc...
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>lookupProjectSpecFor:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		aProjectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'g...etc...
		registration: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ] in [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		version: 	nil
		loadedSpec: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgr...etc...
	Receiver's instance variables: 
		outerContext: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
...etc...
		startpc: 	142
		numArgs: 	0


[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	nil
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'Pillar';
	versionString: #'stable';
	repository: 'gi...etc...
		options: 	a Dictionary()



--- The full stack ---
MetacelloAllowConflictingProjectUpgrade>>defaultAction
UndefinedObject>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
MetacelloAllowConflictingProjectUpgrade(Exception)>>pass
[ ^ exception pass ] in MetacelloScriptEngine>>handleConflict:
Dictionary>>at:ifAbsent:
MetacelloScriptEngine>>handleConflict:
MetacelloAllowConflictingProjectUpgrade>>handleResolutionFor:
[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
Context>>handleSignal:
Context>>handleSignal:
MetacelloAllowConflictingProjectUpgrade(Exception)>>signal
[ :existing :new | 
(existing hasLoadConflicts: new)
	ifTrue: [ ((existing canUpgradeTo: new)
			ifTrue: [ MetacelloAllowProjectUpgrade new ]
			ifFalse: [ (existing canDowngradeTo: new)
					ifTrue: [ MetacelloAllowProjectDowngrade new ]
					ifFalse: [ MetacelloAllowConflictingProjectUpgrade new ] ])
			existingProjectRegistration: existing;
			newProjectRegistration: new;
			signal ]
	ifFalse: [ new ] ] in MetacelloScriptEngine>>lookupProjectSpecFor:
[ :existing | ^ presentBlock value: existing value: newRegistration ] in MetacelloProjectRegistration class>>registrationForProjectSpec:ifAbsent:ifPresent:
[ :existing | ^ presentBlock value: existing ] in MetacelloProjectRegistry>>registrationFor:ifPresent:ifAbsent:
BlockClosure>>cull:
Dictionary>>at:ifPresent:
MetacelloProjectRegistry>>registrationFor:ifPresent:ifAbsent:
MetacelloProjectRegistration class>>registrationForProjectSpec:ifAbsent:ifPresent:
MetacelloScriptEngine>>lookupProjectSpecFor:
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ] in [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in THERE_BE_DRAGONS_HERE
Instance of IceMetacelloProjectRegistration did not understand #register
26 June 2018 5:04:59.65987 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

IceMetacelloProjectRegistration(Object)>>doesNotUnderstand: #register
	Receiver: Chapter1
	Arguments and temporary variables: 
		aMessage: 	register
		exception: 	MessageNotUnderstood: IceMetacelloProjectRegistration>>register
		resumeValue: 	nil
	Receiver's instance variables: 
		version: 	'Chapter1'


MCGitHubRepository(MCGitBasedNetworkRepository)>>createIcebergRepositoryFor:
	Receiver: a MCGitHubRepository(github://QDucasse/MetacelloTestBook-Code:Chapter1)
	Arguments and temporary variables: 
		repository: 	Chapter1
		remoteUrl: 	'git@github.com:QDucasse/MetacelloTestBook-Code.git'
		builder: 	an IceRepositoryCreator
	Receiver's instance variables: 
		creationTemplate: 	nil
		cache: 	nil
		allFileNames: 	nil
		cacheFileNames: 	nil
		directory: 	nil
		readonly: 	true
		repositoryProperties: 	nil
		projectPath: 	'QDucasse/MetacelloTestBook-Code'
		projectVersion: 	'Chapter1'
		repoPath: 	''
		projectVersionPattern: 	nil


[ ^ self createIcebergRepositoryFor: urlToUse ] in MCGitHubRepository(MCGitBasedNetworkRepository)>>createIcebergRepositoryWithFallbackFor:url:
	Receiver: a MCGitHubRepository(github://QDucasse/MetacelloTestBook-Code:Chapter1)
	Arguments and temporary variables: 
		remote: 	noname (git@github.com:QDucasse/MetacelloTestBook-Code.git)
		remoteUrl: 	'git@github.com:QDucasse/MetacelloTestBook-Code.git'
		urlToUse: 	'git@github.com:QDucasse/MetacelloTestBook-Code.git'
	Receiver's instance variables: 
		creationTemplate: 	nil
		cache: 	nil
		allFileNames: 	nil
		cacheFileNames: 	nil
		directory: 	nil
		readonly: 	true
		repositoryProperties: 	nil
		projectPath: 	'QDucasse/MetacelloTestBook-Code'
		projectVersion: 	'Chapter1'
		repoPath: 	''
		projectVersionPattern: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ self createIcebergRepositoryFor: urlToUse ]
	Arguments and temporary variables: 
		exception: 	IceAuthenticationError
		handlerAction: 	[ :e | 
self
	crLog:
		('I got an error while cloning: {1}. I wi...etc...
	Receiver's instance variables: 
		outerContext: 	MCGitHubRepository(MCGitBasedNetworkRepository)>>createIcebergRep...etc...
		startpc: 	61
		numArgs: 	0


MCGitHubRepository(MCGitBasedNetworkRepository)>>createIcebergRepositoryWithFallbackFor:url:
	Receiver: a MCGitHubRepository(github://QDucasse/MetacelloTestBook-Code:Chapter1)
	Arguments and temporary variables: 
		urlToUse: 	'git@github.com:QDucasse/MetacelloTestBook-Code.git'
		remote: 	noname (git@github.com:QDucasse/MetacelloTestBook-Code.git)
		remoteUrl: 	'git@github.com:QDucasse/MetacelloTestBook-Code.git'
	Receiver's instance variables: 
		creationTemplate: 	nil
		cache: 	nil
		allFileNames: 	nil
		cacheFileNames: 	nil
		directory: 	nil
		readonly: 	true
		repositoryProperties: 	nil
		projectPath: 	'QDucasse/MetacelloTestBook-Code'
		projectVersion: 	'Chapter1'
		repoPath: 	''
		projectVersionPattern: 	nil


[ | remote |
remote := IceGitRemote url: remoteUrl.
self createIcebergRepositoryWithFallbackFor: remote url: remoteUrl ] in MCGitHubRepository(MCGitBasedNetworkRepository)>>getOrCreateIcebergRepository
	Receiver: a MCGitHubRepository(github://QDucasse/MetacelloTestBook-Code:Chapter1)
	Arguments and temporary variables: 
		remoteUrl: 	'git@github.com:QDucasse/MetacelloTestBook-Code.git'
		remote: 	noname (git@github.com:QDucasse/MetacelloTestBook-Code.git)
	Receiver's instance variables: 
		creationTemplate: 	nil
		cache: 	nil
		allFileNames: 	nil
		cacheFileNames: 	nil
		directory: 	nil
		readonly: 	true
		repositoryProperties: 	nil
		projectPath: 	'QDucasse/MetacelloTestBook-Code'
		projectVersion: 	'Chapter1'
		repoPath: 	''
		projectVersionPattern: 	nil


OrderedCollection(Collection)>>detect:ifFound:ifNone:
	Receiver: an OrderedCollection(IceLibgitRepository(iceberg) IceLibgitRepository(pharo) IceLibgitRepo...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :repo | repo isCloneOfUrl: remoteUrl ]
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ | remote |
remote := IceGitRemote url: remoteUrl.
self create...etc...
	Receiver's instance variables: 
		array: 	an Array(IceLibgitRepository(iceberg) IceLibgitRepository(pharo) IceLibg...etc...
		firstIndex: 	1
		lastIndex: 	8


OrderedCollection(Collection)>>detect:ifNone:
	Receiver: an OrderedCollection(IceLibgitRepository(iceberg) IceLibgitRepository(pharo) IceLibgitRepo...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :repo | repo isCloneOfUrl: remoteUrl ]
		exceptionBlock: 	[ | remote |
remote := IceGitRemote url: remoteUrl.
self create...etc...
	Receiver's instance variables: 
		array: 	an Array(IceLibgitRepository(iceberg) IceLibgitRepository(pharo) IceLibg...etc...
		firstIndex: 	1
		lastIndex: 	8


MCGitHubRepository(MCGitBasedNetworkRepository)>>getOrCreateIcebergRepository
	Receiver: a MCGitHubRepository(github://QDucasse/MetacelloTestBook-Code:Chapter1)
	Arguments and temporary variables: 
		remoteUrl: 	'git@github.com:QDucasse/MetacelloTestBook-Code.git'
	Receiver's instance variables: 
		creationTemplate: 	nil
		cache: 	nil
		allFileNames: 	nil
		cacheFileNames: 	nil
		directory: 	nil
		readonly: 	true
		repositoryProperties: 	nil
		projectPath: 	'QDucasse/MetacelloTestBook-Code'
		projectVersion: 	'Chapter1'
		repoPath: 	''
		projectVersionPattern: 	nil


IceGithubRepositoryType>>mcRepository
	Receiver: an IceGithubRepositoryType
	Arguments and temporary variables: 
		baseRepo: 	a MCGitHubRepository(github://QDucasse/MetacelloTestBook-Code:Chapter...etc...
	Receiver's instance variables: 
		location: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1'


Iceberg class>>mcRepositoryFor:
	Receiver: Iceberg
	Arguments and temporary variables: 
		aLocationString: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1'
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Iceberg
		classPool: 	a Dictionary(#EnableMetacelloIntegration->true #RemoteTypeSelector->...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Iceberg-Core'
		icebergAnnouncer: 	an IceAnnouncer


IceMetacelloPharoPlatform>>createRepository:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aRepositorySpec: 	spec repository: 'github://QDucasse/MetacelloTestBook-Code:Cha...etc...
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloMCBaselineProject(MetacelloMCProject)>>createRepository:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aRepositorySpec: 	spec repository: 'github://QDucasse/MetacelloTestBook-Code:Cha...etc...
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloRepositorySpec>>createRepository
	Receiver: spec repository: 'github://QDucasse/MetacelloTestBook-Code:Chapter1'
	Arguments and temporary variables: 
		repo: 	nil
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ aSpec createRepository ] in [ :aSpec | 
| description repo |
description := aSpec description.
(repo := repositories
	detect: [ :rep | rep description = description ]
	ifNone: [ aSpec createRepository ]) ~~ nil
	ifTrue: [ repos add: repo ] ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>repositoriesFrom:ignoreOverrides:
	Receiver: a MetacelloFetchingMCSpecLoader(linear load : )
	Arguments and temporary variables: 
		aMetacelloMVRepositorySpecs: 	an Array(spec repository: 'github://QDucasse/Metac...etc...
		ignoreOverrides: 	false
		repositories: 	an Array(a MCCacheRepository(/Users/quentin/Documents/Pharo/image...etc...
		repos: 	an OrderedCollection()
		aSpec: 	spec repository: 'github://QDucasse/MetacelloTestBook-Code:Chapter1'
		description: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1'
		repo: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(Collection)>>detect:ifFound:ifNone:
	Receiver: an Array(a MCCacheRepository(/Users/quentin/Documents/Pharo/images/Pillar-featureMetacello...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :rep | rep description = description ]
		foundBlock: 	[ :element | element ]
		exceptionBlock: 	[ aSpec createRepository ]
	Receiver's instance variables: 
an Array(a MCCacheRepository(/Users/quentin/Documents/Pharo/images/Pillar-featureMetacello...etc...

Array(Collection)>>detect:ifNone:
	Receiver: an Array(a MCCacheRepository(/Users/quentin/Documents/Pharo/images/Pillar-featureMetacello...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :rep | rep description = description ]
		exceptionBlock: 	[ aSpec createRepository ]
	Receiver's instance variables: 
an Array(a MCCacheRepository(/Users/quentin/Documents/Pharo/images/Pillar-featureMetacello...etc...

[ :aSpec | 
| description repo |
description := aSpec description.
(repo := repositories
	detect: [ :rep | rep description = description ]
	ifNone: [ aSpec createRepository ]) ~~ nil
	ifTrue: [ repos add: repo ] ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>repositoriesFrom:ignoreOverrides:
	Receiver: a MetacelloFetchingMCSpecLoader(linear load : )
	Arguments and temporary variables: 
		aMetacelloMVRepositorySpecs: 	an Array(spec repository: 'github://QDucasse/Metac...etc...
		ignoreOverrides: 	false
		repositories: 	an Array(a MCCacheRepository(/Users/quentin/Documents/Pharo/image...etc...
		repos: 	an OrderedCollection()
		aSpec: 	spec repository: 'github://QDucasse/MetacelloTestBook-Code:Chapter1'
		description: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1'
		repo: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec repository: 'github://QDucasse/MetacelloTestBook-Code:Chapter1')
	Arguments and temporary variables: 
		aBlock: 	[ :aSpec | 
| description repo |
description := aSpec description.
(rep...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec repository: 'github://QDucasse/MetacelloTestBook-Code:Chapter1')

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>repositoriesFrom:ignoreOverrides:
	Receiver: a MetacelloFetchingMCSpecLoader(linear load : )
	Arguments and temporary variables: 
		aMetacelloMVRepositorySpecs: 	an Array(spec repository: 'github://QDucasse/Metac...etc...
		ignoreOverrides: 	false
		repositories: 	an Array(a MCCacheRepository(/Users/quentin/Documents/Pharo/image...etc...
		repos: 	an OrderedCollection()
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>repositoriesFrom:
	Receiver: a MetacelloFetchingMCSpecLoader(linear load : )
	Arguments and temporary variables: 
		aMetacelloMVRepositorySpecs: 	an Array(spec repository: 'github://QDucasse/Metac...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(linear load : )
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex allow ] #onUpgrade->[ :ex | ex al...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex allow ] #onUpgrade->[ :ex | ex al...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex allow ] #onUpgrade->[ :ex | ex al...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestBook-Code:C...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/M...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex allow ] #onUpgrade->[ :ex | ex al...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex allow ] #onUpgrade->[ :ex | ex al...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex allow ] #onUpgrade->[ :ex | ex al...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex allow ] #onUpgrade->[ :ex | ex al...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex allow ] #onUpgrade->[ :ex | ex al...etc...



--- The full stack ---
IceMetacelloProjectRegistration(Object)>>doesNotUnderstand: #register
MCGitHubRepository(MCGitBasedNetworkRepository)>>createIcebergRepositoryFor:
[ ^ self createIcebergRepositoryFor: urlToUse ] in MCGitHubRepository(MCGitBasedNetworkRepository)>>createIcebergRepositoryWithFallbackFor:url:
BlockClosure>>on:do:
MCGitHubRepository(MCGitBasedNetworkRepository)>>createIcebergRepositoryWithFallbackFor:url:
[ | remote |
remote := IceGitRemote url: remoteUrl.
self createIcebergRepositoryWithFallbackFor: remote url: remoteUrl ] in MCGitHubRepository(MCGitBasedNetworkRepository)>>getOrCreateIcebergRepository
OrderedCollection(Collection)>>detect:ifFound:ifNone:
OrderedCollection(Collection)>>detect:ifNone:
MCGitHubRepository(MCGitBasedNetworkRepository)>>getOrCreateIcebergRepository
IceGithubRepositoryType>>mcRepository
Iceberg class>>mcRepositoryFor:
IceMetacelloPharoPlatform>>createRepository:
MetacelloMCBaselineProject(MetacelloMCProject)>>createRepository:
MetacelloRepositorySpec>>createRepository
[ aSpec createRepository ] in [ :aSpec | 
| description repo |
description := aSpec description.
(repo := repositories
	detect: [ :rep | rep description = description ]
	ifNone: [ aSpec createRepository ]) ~~ nil
	ifTrue: [ repos add: repo ] ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>repositoriesFrom:ignoreOverrides:
Array(Collection)>>detect:ifFound:ifNone:
Array(Collection)>>detect:ifNone:
[ :aSpec | 
| description repo |
description := aSpec description.
(repo := repositories
	detect: [ :rep | rep description = description ]
	ifNone: [ aSpec createRepository ]) ~~ nil
	ifTrue: [ repos add: repo ] ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>repositoriesFrom:ignoreOverrides:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>repositoriesFrom:ignoreOverrides:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>repositoriesFrom:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[Chapter1]
26 June 2018 5:06:08.370639 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucass...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestBook-Code:C...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/M...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#baselineArg:->#('MetacelloTestBook') #reposit...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1'


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1'


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[Chapter1]
26 June 2018 5:06:34.075401 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucass...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestBook-Code:C...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/M...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#baselineArg:->#('MetacelloTestBook') #reposit...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1/src'


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1/src'


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[Chapter1]
26 June 2018 5:07:39.781467 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucass...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestBook-Code:C...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/M...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#baselineArg:->#('MetacelloTestBook') #reposit...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1/src'


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1/src'


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[Chapter1]
26 June 2018 5:08:08.36914 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucass...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestBook-Code:C...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/M...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#baselineArg:->#('MetacelloTestBook') #reposit...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1/src'


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1/src'


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[Chapter1]
26 June 2018 5:10:11.774669 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucass...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestBook-Code:C...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/M...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#baselineArg:->#('MetacelloTestBook') #reposit...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1/src'


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code:Chapter1/src'


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[Chapter1]
26 June 2018 5:11:12.195406 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///User...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quent...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quent...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Documents/Pharo/...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/q...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#repositoryArg:->#('gitlocal:///Users/quentin/...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#())
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'gitlocal:///Users/quentin/Documents/Pharo/images/Pillar-feature...etc...


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#())
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'gitlocal:///Users/quentin/Documents/Pharo/images/Pillar-feature...etc...


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>basicInstallBaseline:groups:
[ self basicInstallBaseline: icePackage groups: anArray ] in [ Iceberg announcer
	suspendAllForRepository: self repositoryModel entity
	while: [ self basicInstallBaseline: icePackage groups: anArray ] ] in IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
BlockClosure>>ensure:
IceAnnouncer>>suspendAllMatching:while:
IceAnnouncer>>suspendAllForRepository:while:
[ Iceberg announcer
	suspendAllForRepository: self repositoryModel entity
	while: [ self basicInstallBaseline: icePackage groups: anArray ] ] in IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:
IceTipMetacelloInstallBaselineDefaultCommand>>execute
IceTipWorkingCopyContext(CmdToolContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[gggg]
26 June 2018 5:11:31.84141 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///User...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quent...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quent...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	nil
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: <<error during printing>>
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	nil
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	nil
		configuration: 	<<error during printing>>

MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Documents/Pharo/...etc...
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/q...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#repositoryArg:->#('gitlocal:///Users/quentin/...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#())
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'gitlocal:///Users/quentin/Documents/Pharo/images/Pillar-feature...etc...


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#())
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'gitlocal:///Users/quentin/Documents/Pharo/images/Pillar-feature...etc...


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>basicInstallBaseline:groups:
[ self basicInstallBaseline: icePackage groups: anArray ] in [ Iceberg announcer
	suspendAllForRepository: self repositoryModel entity
	while: [ self basicInstallBaseline: icePackage groups: anArray ] ] in IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
BlockClosure>>ensure:
IceAnnouncer>>suspendAllMatching:while:
IceAnnouncer>>suspendAllForRepository:while:
[ Iceberg announcer
	suspendAllForRepository: self repositoryModel entity
	while: [ self basicInstallBaseline: icePackage groups: anArray ] ] in IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:
IceTipMetacelloInstallBaselineDefaultCommand>>execute
IceTipWorkingCopyContext(CmdToolContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[gggg]
26 June 2018 5:11:39.041105 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///User...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quent...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quent...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	a MCWorkingCopy(BaselineOfMetacelloTestBook)
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	a Dictionary('baseline'->baseline [BaselineOfMetacelloTestBook] )
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	#linear
		configuration: 	a BaselineOfMetacelloTestBook
		projectAttributes: 	#()
		versionNumberClass: 	MetacelloVersionNumber


MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	a Dictionary('baseline'->baseline [BaselineOfMetacelloTestBook] )
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	#linear
		configuration: 	a BaselineOfMetacelloTestBook
		projectAttributes: 	#()
		versionNumberClass: 	MetacelloVersionNumber


MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Documents/Pharo/...etc...
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		prj: 	BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/q...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#repositoryArg:->#('gitlocal:///Users/quentin/...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#())
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'gitlocal:///Users/quentin/Documents/Pharo/images/Pillar-feature...etc...


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#())
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'gitlocal:///Users/quentin/Documents/Pharo/images/Pillar-feature...etc...


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>basicInstallBaseline:groups:
[ self basicInstallBaseline: icePackage groups: anArray ] in [ Iceberg announcer
	suspendAllForRepository: self repositoryModel entity
	while: [ self basicInstallBaseline: icePackage groups: anArray ] ] in IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
BlockClosure>>ensure:
IceAnnouncer>>suspendAllMatching:while:
IceAnnouncer>>suspendAllForRepository:while:
[ Iceberg announcer
	suspendAllForRepository: self repositoryModel entity
	while: [ self basicInstallBaseline: icePackage groups: anArray ] ] in IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:
IceTipMetacelloInstallBaselineDefaultCommand>>execute
IceTipWorkingCopyContext(CmdToolContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[gggg]
26 June 2018 5:12:21.248498 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///User...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quent...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quent...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Use...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	a MCWorkingCopy(BaselineOfMetacelloTestBook)
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Docume...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	a Dictionary('baseline'->baseline [BaselineOfMetacelloTestBook] )
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	#linear
		configuration: 	a BaselineOfMetacelloTestBook
		projectAttributes: 	#()
		versionNumberClass: 	MetacelloVersionNumber


MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	a Dictionary('baseline'->baseline [BaselineOfMetacelloTestBook] )
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	#linear
		configuration: 	a BaselineOfMetacelloTestBook
		projectAttributes: 	#()
		versionNumberClass: 	MetacelloVersionNumber


MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/quentin/Documents/Pharo/...etc...
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		prj: 	BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/q...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#()
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#repositoryArg:->#('gitlocal:///Users/quentin/...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'gitlocal:///Users/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#())
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'gitlocal:///Users/quentin/Documents/Pharo/images/Pillar-feature...etc...


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :e | 
| policy |
policy := self chooseConf...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#())
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'gitlocal:///Users/quentin/Documents/Pharo/images/Pillar-feature...etc...


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>basicInstallBaseline:groups:
[ self basicInstallBaseline: icePackage groups: anArray ] in [ Iceberg announcer
	suspendAllForRepository: self repositoryModel entity
	while: [ self basicInstallBaseline: icePackage groups: anArray ] ] in IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
BlockClosure>>ensure:
IceAnnouncer>>suspendAllMatching:while:
IceAnnouncer>>suspendAllForRepository:while:
[ Iceberg announcer
	suspendAllForRepository: self repositoryModel entity
	while: [ self basicInstallBaseline: icePackage groups: anArray ] ] in IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
[ :bar | 
bar label: aString.
aBlock value ] in MorphicUIManager(UIManager)>>informUser:during:
[ :bar | aBlock value: bar ] in MorphicUIManager>>informUserDuring:
BlockClosure>>cull:
[ ^ block cull: self ] in [ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
[ activeProcess psValueAt: index put: anObject.
aBlock value ] in CurrentJob(DynamicVariable)>>value:during:
BlockClosure>>ensure:
CurrentJob(DynamicVariable)>>value:during:
CurrentJob class(DynamicVariable class)>>value:during:
[ self prepareForRunning.
CurrentJob value: self during: [ ^ block cull: self ] ] in Job>>run
BlockClosure>>ensure:
Job>>run
MorphicUIManager(UIManager)>>displayProgress:from:to:during:
MorphicUIManager>>informUserDuring:
MorphicUIManager(UIManager)>>informUser:during:
IceTipStandardAction>>basicExecute
[ self basicExecute.
self finishSuccess ] in IceTipStandardAction(IceTipAction)>>execute
BlockClosure>>on:do:
IceTipStandardAction(IceTipAction)>>withErrorHandlingDo:
IceTipStandardAction(IceTipAction)>>execute
IceTipStandardAction>>execute:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:groups:
IceTipMetacelloInstallBaselineDefaultCommand(IceTipMetacelloInstallBaselineCommand)>>installBaseline:
IceTipMetacelloInstallBaselineDefaultCommand>>execute
IceTipWorkingCopyContext(CmdToolContext)>>executeCommand:by:
[ self prepareCommandForExecution.
context executeCommand: command by: self.
self applyCommandResult ] in CmdCommandActivator>>executeCommand
BlockClosure>>on:do:
CmdCommandActivator>>executeCommand
[ | selArgCount |
"show cursor in case item opens a new MVC window"
(selArgCount := selector numArgs) = 0
	ifTrue: [ target perform: selector ]
	ifFalse: [ selArgCount = arguments size
			ifTrue: [ target perform: selector withArguments: arguments ]
			ifFalse: [ target perform: selector withArguments: (arguments copyWith: evt) ] ].
self showShortcut.
self changed ] in ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
BlockClosure>>ensure:
CursorWithMask(Cursor)>>showWhile:
ToggleMenuItemMorph(MenuItemMorph)>>invokeWithEvent:
ToggleMenuItemMorph(MenuItemMorph)>>mouseUp:
ToggleMenuItemMorph(MenuItemMorph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
ToggleMenuItemMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
ToggleMenuItemMorph(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
MenuMorph(Morph)>>processEvent:using:
MenuMorph(Morph)>>processEvent:
MenuMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[master]
26 June 2018 5:14:44.047803 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucass...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	a MCWorkingCopy(BaselineOfMetacelloTestBook)
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	a Dictionary('baseline'->baseline [BaselineOfMetacelloTestBook] )
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	#linear
		configuration: 	a BaselineOfMetacelloTestBook
		projectAttributes: 	#()
		versionNumberClass: 	MetacelloVersionNumber


MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	a Dictionary('baseline'->baseline [BaselineOfMetacelloTestBook] )
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	#linear
		configuration: 	a BaselineOfMetacelloTestBook
		projectAttributes: 	#()
		versionNumberClass: 	MetacelloVersionNumber


MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestBook-Code/s...etc...
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		prj: 	BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/M...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#baselineArg:->#('MetacelloTestBook') #reposit...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code/src'


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code/src'


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
NotFound: Object not found - no match for id (560d041efb101566775a516c29f690227fdaa558)
26 June 2018 5:20:16.13671 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

IceLibgitErrorVisitor>>visitENOTFOUND:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb1015...etc...
	Receiver's instance variables: 
		context: 	IceLibgitRepository(MetacelloTestBook-Code)


LGit_GIT_ENOTFOUND>>acceptError:
	Receiver: LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566775a516c29f690227f...etc...
	Arguments and temporary variables: 
		aVisitor: 	an IceLibgitErrorVisitor
	Receiver's instance variables: 
		messageText: 	'Object not found - no match for id (560d041efb101566775a516c29f69...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_enotfound [-3])
		signalContext: 	LGit_GIT_ENOTFOUND(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_odb [9])


[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 
		aBlock: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
		error: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566...etc...
	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	''
		commitCache: 	a LRUCache(#7 7/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


BlockClosure>>cull:
	Receiver: [ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ]
	Arguments and temporary variables: 
		anArg: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566...etc...
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>handleLibgitError:
		startpc: 	39
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb10...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb10...etc...
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]


LGit_GIT_ENOTFOUND(Exception)>>signal
	Receiver: LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566775a516c29f690227f...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Object not found - no match for id (560d041efb101566775a516c29f69...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_enotfound [-3])
		signalContext: 	LGit_GIT_ENOTFOUND(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_odb [9])


LGit_GIT_ENOTFOUND class(LGitCallReturnHandler class)>>signalWith:
	Receiver: LGit_GIT_ENOTFOUND
	Arguments and temporary variables: 
		anError: 	a LGitError ()
	Receiver's instance variables: 
		superclass: 	LGitCallReturnHandler
		methodDict: 	a MethodDictionary(#acceptError:->LGit_GIT_ENOTFOUND>>#acceptError:...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGit_GIT_ENOTFOUND
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-Exceptions-ReturnCodes'


LGitReturnCodeEnum>>handleLGitReturnCode
	Receiver: a LGitReturnCodeEnum(#git_enotfound [-3])
	Arguments and temporary variables: 
		handler: 	LGit_GIT_ENOTFOUND
	Receiver's instance variables: 
		value: 	-3


LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		callBlock: 	[ self commit_lookup: self repo: self repository id: self id ]
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit>>lookup
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit(LGitObject)>>initializeWithId:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		gitOid: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit class(LGitObject class)>>of:fromId:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-fea...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInRepository:...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGitCommit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


LGitCommit class>>of:fromHexString:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-fea...etc...
		aCommitId: 	'560d041efb101566775a516c29f690227fdaa558'
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInRepository:...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGitCommit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ] in IceGitCommit>>libgitCommit
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc...
	Receiver's instance variables: 
		outerContext: 	IceGitCommit>>libgitCommit
		startpc: 	38
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 
		aBlock: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	''
		commitCache: 	a LRUCache(#7 7/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


IceGitCommit>>libgitCommit
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>fileSystem
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceRepositoryProperties class>>fromCommitish:
	Receiver: IceRepositoryProperties
	Arguments and temporary variables: 
		aCommitish: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		ref: 	nil
		properties: 	nil
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		dir: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#at:->IceRepositoryProperties>>#at: #at:put:->Ic...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IceRepositoryProperties
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Iceberg-Libgit-Core'


IceGitCommit>>properties
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>writerClass
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>fetchPackageNames
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 
		writerClass: 	nil
		dir: 	nil
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>DoItIn:
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 
		ThisContext: 	IceGitCommit>>packageNames
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext
	^ self fetchPackageNames
		source: 	a ReadStream
		context: 	IceGitCommit>>packageNames
		receiver: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		ctxt: 	IceGitCommit>>packageNames
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(188132352)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(188132352)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(60728320)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoMethodRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoMethodRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	1164924
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoMethodRenderer)
	Arguments and temporary variables: 
		anArgument: 	1164939
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoMethodRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	1164924
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	1164939
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25189888)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1164916
		lastStepMessage: 	nil
		lastCycleTime: 	1164939
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25189888)))
		lastAlarmTime: 	1164916
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		now: 	1164939
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1164916
		lastStepMessage: 	nil
		lastCycleTime: 	1164939
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25189888)))
		lastAlarmTime: 	1164916
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1164916
		lastStepMessage: 	nil
		lastCycleTime: 	1164939
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25189888)))
		lastAlarmTime: 	1164916
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1164916
		lastStepMessage: 	nil
		lastCycleTime: 	1164939
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25189888)))
		lastAlarmTime: 	1164916
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1164916
		lastStepMessage: 	nil
		lastCycleTime: 	1164939
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(25189888)))
		lastAlarmTime: 	1164916
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(62...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil



--- The full stack ---
IceLibgitErrorVisitor>>visitENOTFOUND:
LGit_GIT_ENOTFOUND>>acceptError:
[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
LGit_GIT_ENOTFOUND(Exception)>>signal
LGit_GIT_ENOTFOUND class(LGitCallReturnHandler class)>>signalWith:
LGitReturnCodeEnum>>handleLGitReturnCode
LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
LGitCommit>>lookup
LGitCommit(LGitObject)>>initializeWithId:
LGitCommit class(LGitObject class)>>of:fromId:
LGitCommit class>>of:fromHexString:
[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ] in IceGitCommit>>libgitCommit
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitCommit>>libgitCommit
IceGitCommit>>fileSystem
IceRepositoryProperties class>>fromCommitish:
IceGitCommit>>properties
IceGitCommit>>writerClass
IceGitCommit>>fetchPackageNames
IceGitCommit>>DoItIn:
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
NotFound: Object not found - no match for id (560d041efb101566775a516c29f690227fdaa558)
26 June 2018 5:20:42.657747 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

IceLibgitErrorVisitor>>visitENOTFOUND:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb1015...etc...
	Receiver's instance variables: 
		context: 	IceLibgitRepository(MetacelloTestBook-Code)


LGit_GIT_ENOTFOUND>>acceptError:
	Receiver: LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566775a516c29f690227f...etc...
	Arguments and temporary variables: 
		aVisitor: 	an IceLibgitErrorVisitor
	Receiver's instance variables: 
		messageText: 	'Object not found - no match for id (560d041efb101566775a516c29f69...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_enotfound [-3])
		signalContext: 	LGit_GIT_ENOTFOUND(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_odb [9])


[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 
		aBlock: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
		error: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566...etc...
	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	''
		commitCache: 	a LRUCache(#7 7/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


BlockClosure>>cull:
	Receiver: [ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ]
	Arguments and temporary variables: 
		anArg: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566...etc...
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>handleLibgitError:
		startpc: 	39
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb10...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb10...etc...
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]


LGit_GIT_ENOTFOUND(Exception)>>signal
	Receiver: LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566775a516c29f690227f...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Object not found - no match for id (560d041efb101566775a516c29f69...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_enotfound [-3])
		signalContext: 	LGit_GIT_ENOTFOUND(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_odb [9])


LGit_GIT_ENOTFOUND class(LGitCallReturnHandler class)>>signalWith:
	Receiver: LGit_GIT_ENOTFOUND
	Arguments and temporary variables: 
		anError: 	a LGitError ()
	Receiver's instance variables: 
		superclass: 	LGitCallReturnHandler
		methodDict: 	a MethodDictionary(#acceptError:->LGit_GIT_ENOTFOUND>>#acceptError:...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGit_GIT_ENOTFOUND
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-Exceptions-ReturnCodes'


LGitReturnCodeEnum>>handleLGitReturnCode
	Receiver: a LGitReturnCodeEnum(#git_enotfound [-3])
	Arguments and temporary variables: 
		handler: 	LGit_GIT_ENOTFOUND
	Receiver's instance variables: 
		value: 	-3


LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		callBlock: 	[ self commit_lookup: self repo: self repository id: self id ]
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit>>lookup
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit(LGitObject)>>initializeWithId:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		gitOid: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit class(LGitObject class)>>of:fromId:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-fea...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInRepository:...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGitCommit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


LGitCommit class>>of:fromHexString:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-fea...etc...
		aCommitId: 	'560d041efb101566775a516c29f690227fdaa558'
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInRepository:...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGitCommit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ] in IceGitCommit>>libgitCommit
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc...
	Receiver's instance variables: 
		outerContext: 	IceGitCommit>>libgitCommit
		startpc: 	38
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 
		aBlock: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	''
		commitCache: 	a LRUCache(#7 7/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


IceGitCommit>>libgitCommit
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>fileSystem
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceRepositoryProperties class>>fromCommitish:
	Receiver: IceRepositoryProperties
	Arguments and temporary variables: 
		aCommitish: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		ref: 	nil
		properties: 	nil
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		dir: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#at:->IceRepositoryProperties>>#at: #at:put:->Ic...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IceRepositoryProperties
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Iceberg-Libgit-Core'


IceGitCommit>>properties
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>DoItIn:
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 
		ThisContext: 	IceGitCommit>>writerClass
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext
	^ self properties
		source: 	a ReadStream
		context: 	IceGitCommit>>writerClass
		receiver: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		ctxt: 	IceGitCommit>>writerClass
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(358380032)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(358380032)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(781463040)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoMethodRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoMethodRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	1191443
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoMethodRenderer)
	Arguments and temporary variables: 
		anArgument: 	1191462
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoMethodRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	1191443
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	1191462
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(472912896)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1191441
		lastStepMessage: 	nil
		lastCycleTime: 	1191462
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(472912896)))
		lastAlarmTime: 	1191441
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		now: 	1191462
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1191441
		lastStepMessage: 	nil
		lastCycleTime: 	1191462
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(472912896)))
		lastAlarmTime: 	1191441
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1191441
		lastStepMessage: 	nil
		lastCycleTime: 	1191462
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(472912896)))
		lastAlarmTime: 	1191441
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1191441
		lastStepMessage: 	nil
		lastCycleTime: 	1191462
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(472912896)))
		lastAlarmTime: 	1191441
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1191441
		lastStepMessage: 	nil
		lastCycleTime: 	1191462
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(472912896)))
		lastAlarmTime: 	1191441
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(62...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
IceLibgitErrorVisitor>>visitENOTFOUND:
LGit_GIT_ENOTFOUND>>acceptError:
[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
LGit_GIT_ENOTFOUND(Exception)>>signal
LGit_GIT_ENOTFOUND class(LGitCallReturnHandler class)>>signalWith:
LGitReturnCodeEnum>>handleLGitReturnCode
LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
LGitCommit>>lookup
LGitCommit(LGitObject)>>initializeWithId:
LGitCommit class(LGitObject class)>>of:fromId:
LGitCommit class>>of:fromHexString:
[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ] in IceGitCommit>>libgitCommit
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitCommit>>libgitCommit
IceGitCommit>>fileSystem
IceRepositoryProperties class>>fromCommitish:
IceGitCommit>>properties
IceGitCommit>>DoItIn:
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
NotFound: Object not found - no match for id (560d041efb101566775a516c29f690227fdaa558)
26 June 2018 5:20:57.292857 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

IceLibgitErrorVisitor>>visitENOTFOUND:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb1015...etc...
	Receiver's instance variables: 
		context: 	IceLibgitRepository(MetacelloTestBook-Code)


LGit_GIT_ENOTFOUND>>acceptError:
	Receiver: LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566775a516c29f690227f...etc...
	Arguments and temporary variables: 
		aVisitor: 	an IceLibgitErrorVisitor
	Receiver's instance variables: 
		messageText: 	'Object not found - no match for id (560d041efb101566775a516c29f69...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_enotfound [-3])
		signalContext: 	LGit_GIT_ENOTFOUND(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_odb [9])


[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 
		aBlock: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
		error: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566...etc...
	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	''
		commitCache: 	a LRUCache(#7 7/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


BlockClosure>>cull:
	Receiver: [ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ]
	Arguments and temporary variables: 
		anArg: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566...etc...
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>handleLibgitError:
		startpc: 	39
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb10...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb10...etc...
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]


LGit_GIT_ENOTFOUND(Exception)>>signal
	Receiver: LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566775a516c29f690227f...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Object not found - no match for id (560d041efb101566775a516c29f69...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_enotfound [-3])
		signalContext: 	LGit_GIT_ENOTFOUND(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_odb [9])


LGit_GIT_ENOTFOUND class(LGitCallReturnHandler class)>>signalWith:
	Receiver: LGit_GIT_ENOTFOUND
	Arguments and temporary variables: 
		anError: 	a LGitError ()
	Receiver's instance variables: 
		superclass: 	LGitCallReturnHandler
		methodDict: 	a MethodDictionary(#acceptError:->LGit_GIT_ENOTFOUND>>#acceptError:...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGit_GIT_ENOTFOUND
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-Exceptions-ReturnCodes'


LGitReturnCodeEnum>>handleLGitReturnCode
	Receiver: a LGitReturnCodeEnum(#git_enotfound [-3])
	Arguments and temporary variables: 
		handler: 	LGit_GIT_ENOTFOUND
	Receiver's instance variables: 
		value: 	-3


LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		callBlock: 	[ self commit_lookup: self repo: self repository id: self id ]
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit>>lookup
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit(LGitObject)>>initializeWithId:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		gitOid: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit class(LGitObject class)>>of:fromId:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-fea...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInRepository:...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGitCommit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


LGitCommit class>>of:fromHexString:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-fea...etc...
		aCommitId: 	'560d041efb101566775a516c29f690227fdaa558'
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInRepository:...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGitCommit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ] in IceGitCommit>>libgitCommit
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc...
	Receiver's instance variables: 
		outerContext: 	IceGitCommit>>libgitCommit
		startpc: 	38
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 
		aBlock: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	''
		commitCache: 	a LRUCache(#7 7/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


IceGitCommit>>libgitCommit
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>DoItIn:
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 
		ThisContext: 	IceGitCommit>>fileSystem
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext
	^ self libgitCommit
		source: 	a ReadStream
		context: 	IceGitCommit>>fileSystem
		receiver: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		ctxt: 	IceGitCommit>>fileSystem
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(803106304)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(803106304)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(166810112)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoMethodRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoMethodRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	1206082
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoMethodRenderer)
	Arguments and temporary variables: 
		anArgument: 	1206099
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoMethodRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	1206082
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	1206099
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(113783808)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1206076
		lastStepMessage: 	nil
		lastCycleTime: 	1206099
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(113783808)))
		lastAlarmTime: 	1206076
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		now: 	1206099
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1206076
		lastStepMessage: 	nil
		lastCycleTime: 	1206099
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(113783808)))
		lastAlarmTime: 	1206076
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1206076
		lastStepMessage: 	nil
		lastCycleTime: 	1206099
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(113783808)))
		lastAlarmTime: 	1206076
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1206076
		lastStepMessage: 	nil
		lastCycleTime: 	1206099
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(113783808)))
		lastAlarmTime: 	1206076
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(153148416))(a SearchMorp...etc...
		lastStepTime: 	1206076
		lastStepMessage: 	nil
		lastCycleTime: 	1206099
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(113783808)))
		lastAlarmTime: 	1206076
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(62...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
IceLibgitErrorVisitor>>visitENOTFOUND:
LGit_GIT_ENOTFOUND>>acceptError:
[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
LGit_GIT_ENOTFOUND(Exception)>>signal
LGit_GIT_ENOTFOUND class(LGitCallReturnHandler class)>>signalWith:
LGitReturnCodeEnum>>handleLGitReturnCode
LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
LGitCommit>>lookup
LGitCommit(LGitObject)>>initializeWithId:
LGitCommit class(LGitObject class)>>of:fromId:
LGitCommit class>>of:fromHexString:
[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ] in IceGitCommit>>libgitCommit
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitCommit>>libgitCommit
IceGitCommit>>DoItIn:
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
NotFound: Object not found - no match for id (560d041efb101566775a516c29f690227fdaa558)
26 June 2018 5:22:52.955195 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

IceLibgitErrorVisitor>>visitENOTFOUND:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb1015...etc...
	Receiver's instance variables: 
		context: 	IceLibgitRepository(MetacelloTestBook-Code)


LGit_GIT_ENOTFOUND>>acceptError:
	Receiver: LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566775a516c29f690227f...etc...
	Arguments and temporary variables: 
		aVisitor: 	an IceLibgitErrorVisitor
	Receiver's instance variables: 
		messageText: 	'Object not found - no match for id (560d041efb101566775a516c29f69...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_enotfound [-3])
		signalContext: 	LGit_GIT_ENOTFOUND(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_odb [9])


[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 
		aBlock: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
		error: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566...etc...
	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	''
		commitCache: 	a LRUCache(#7 7/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


BlockClosure>>cull:
	Receiver: [ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ]
	Arguments and temporary variables: 
		anArg: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566...etc...
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>handleLibgitError:
		startpc: 	39
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb10...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb10...etc...
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]


LGit_GIT_ENOTFOUND(Exception)>>signal
	Receiver: LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566775a516c29f690227f...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Object not found - no match for id (560d041efb101566775a516c29f69...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_enotfound [-3])
		signalContext: 	LGit_GIT_ENOTFOUND(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_odb [9])


LGit_GIT_ENOTFOUND class(LGitCallReturnHandler class)>>signalWith:
	Receiver: LGit_GIT_ENOTFOUND
	Arguments and temporary variables: 
		anError: 	a LGitError ()
	Receiver's instance variables: 
		superclass: 	LGitCallReturnHandler
		methodDict: 	a MethodDictionary(#acceptError:->LGit_GIT_ENOTFOUND>>#acceptError:...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGit_GIT_ENOTFOUND
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-Exceptions-ReturnCodes'


LGitReturnCodeEnum>>handleLGitReturnCode
	Receiver: a LGitReturnCodeEnum(#git_enotfound [-3])
	Arguments and temporary variables: 
		handler: 	LGit_GIT_ENOTFOUND
	Receiver's instance variables: 
		value: 	-3


LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		callBlock: 	[ self commit_lookup: self repo: self repository id: self id ]
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit>>lookup
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit(LGitObject)>>initializeWithId:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		gitOid: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit class(LGitObject class)>>of:fromId:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-fea...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInRepository:...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGitCommit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


LGitCommit class>>of:fromHexString:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-fea...etc...
		aCommitId: 	'560d041efb101566775a516c29f690227fdaa558'
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInRepository:...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGitCommit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ] in IceGitCommit>>libgitCommit
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc...
	Receiver's instance variables: 
		outerContext: 	IceGitCommit>>libgitCommit
		startpc: 	38
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 
		aBlock: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	''
		commitCache: 	a LRUCache(#7 7/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


IceGitCommit>>libgitCommit
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>fileSystem
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceRepositoryProperties class>>fromCommitish:
	Receiver: IceRepositoryProperties
	Arguments and temporary variables: 
		aCommitish: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		ref: 	nil
		properties: 	nil
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		dir: 	nil
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#at:->IceRepositoryProperties>>#at: #at:put:->Ic...etc...
		format: 	65538
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#IceRepositoryProperties
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Iceberg-Libgit-Core'


IceGitCommit>>properties
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>writerClass
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>fetchPackageNames
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 
		writerClass: 	nil
		dir: 	nil
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>packageNames
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit(IceCommit)>>packages
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceWorkingCopy>>DoItIn:
	Receiver: an IceWorkingCopy
	Arguments and temporary variables: 
		ThisContext: 	IceWorkingCopy>>refreshPackages
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packages: 	a Dictionary()
		referenceCommit: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		shouldIgnoreNotifications: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext
	^ self referenceCommit packages
		source: 	a ReadStream
		context: 	IceWorkingCopy>>refreshPackages
		receiver: 	an IceWorkingCopy
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	an IceWorkingCopy
		ctxt: 	IceWorkingCopy>>refreshPackages
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(890471936)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(890471936)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(330922496)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoMethodRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoMethodRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	1321739
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoMethodRenderer)
	Arguments and temporary variables: 
		anArgument: 	1321759
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoMethodRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	1321739
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	1321759
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(939631104)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(369390592))(a DropList...etc...
		lastStepTime: 	1321738
		lastStepMessage: 	nil
		lastCycleTime: 	1321759
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(939631104)))
		lastAlarmTime: 	1321738
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		now: 	1321759
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(369390592))(a DropList...etc...
		lastStepTime: 	1321738
		lastStepMessage: 	nil
		lastCycleTime: 	1321759
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(939631104)))
		lastAlarmTime: 	1321738
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(369390592))(a DropList...etc...
		lastStepTime: 	1321738
		lastStepMessage: 	nil
		lastCycleTime: 	1321759
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(939631104)))
		lastAlarmTime: 	1321738
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(369390592))(a DropList...etc...
		lastStepTime: 	1321738
		lastStepMessage: 	nil
		lastCycleTime: 	1321759
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(939631104)))
		lastAlarmTime: 	1321738
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(369390592))(a DropList...etc...
		lastStepTime: 	1321738
		lastStepMessage: 	nil
		lastCycleTime: 	1321759
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(939631104)))
		lastAlarmTime: 	1321738
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil



--- The full stack ---
IceLibgitErrorVisitor>>visitENOTFOUND:
LGit_GIT_ENOTFOUND>>acceptError:
[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
LGit_GIT_ENOTFOUND(Exception)>>signal
LGit_GIT_ENOTFOUND class(LGitCallReturnHandler class)>>signalWith:
LGitReturnCodeEnum>>handleLGitReturnCode
LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
LGitCommit>>lookup
LGitCommit(LGitObject)>>initializeWithId:
LGitCommit class(LGitObject class)>>of:fromId:
LGitCommit class>>of:fromHexString:
[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ] in IceGitCommit>>libgitCommit
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitCommit>>libgitCommit
IceGitCommit>>fileSystem
IceRepositoryProperties class>>fromCommitish:
IceGitCommit>>properties
IceGitCommit>>writerClass
IceGitCommit>>fetchPackageNames
IceGitCommit>>packageNames
IceGitCommit(IceCommit)>>packages
IceWorkingCopy>>DoItIn:
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
NotFound: Object not found - no match for id (560d041efb101566775a516c29f690227fdaa558)
26 June 2018 5:23:40.668038 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

IceLibgitErrorVisitor>>visitENOTFOUND:
	Receiver: an IceLibgitErrorVisitor
	Arguments and temporary variables: 
		anError: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb1015...etc...
	Receiver's instance variables: 
		context: 	IceLibgitRepository(MetacelloTestBook-Code)


LGit_GIT_ENOTFOUND>>acceptError:
	Receiver: LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566775a516c29f690227f...etc...
	Arguments and temporary variables: 
		aVisitor: 	an IceLibgitErrorVisitor
	Receiver's instance variables: 
		messageText: 	'Object not found - no match for id (560d041efb101566775a516c29f69...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_enotfound [-3])
		signalContext: 	LGit_GIT_ENOTFOUND(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_odb [9])


[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 
		aBlock: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
		error: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566...etc...
	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	''
		commitCache: 	a LRUCache(#7 7/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


BlockClosure>>cull:
	Receiver: [ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ]
	Arguments and temporary variables: 
		anArg: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566...etc...
	Receiver's instance variables: 
		outerContext: 	IceLibgitRepository>>handleLibgitError:
		startpc: 	39
		numArgs: 	1


Context>>evaluateSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb10...etc...
		value: 	nil
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]


Context>>handleSignal:
	Receiver: BlockClosure>>on:do:
	Arguments and temporary variables: 
		exception: 	LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb10...etc...
	Receiver's instance variables: 
		sender: 	IceLibgitRepository>>handleLibgitError:
		pc: 	18
		stackp: 	2
		method: 	BlockClosure>>#on:do:
		closureOrNil: 	nil
		receiver: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]


LGit_GIT_ENOTFOUND(Exception)>>signal
	Receiver: LGit_GIT_ENOTFOUND: Object not found - no match for id (560d041efb101566775a516c29f690227f...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		messageText: 	'Object not found - no match for id (560d041efb101566775a516c29f69...etc...
		tag: 	nil
		signaler: 	a LGitReturnCodeEnum(#git_enotfound [-3])
		signalContext: 	LGit_GIT_ENOTFOUND(Exception)>>signal
		handlerContext: 	BlockClosure>>on:do:
		outerContext: 	nil
		object: 	a LGitErrorTypeEnum(#giterr_odb [9])


LGit_GIT_ENOTFOUND class(LGitCallReturnHandler class)>>signalWith:
	Receiver: LGit_GIT_ENOTFOUND
	Arguments and temporary variables: 
		anError: 	a LGitError ()
	Receiver's instance variables: 
		superclass: 	LGitCallReturnHandler
		methodDict: 	a MethodDictionary(#acceptError:->LGit_GIT_ENOTFOUND>>#acceptError:...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGit_GIT_ENOTFOUND
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-Exceptions-ReturnCodes'


LGitReturnCodeEnum>>handleLGitReturnCode
	Receiver: a LGitReturnCodeEnum(#git_enotfound [-3])
	Arguments and temporary variables: 
		handler: 	LGit_GIT_ENOTFOUND
	Receiver's instance variables: 
		value: 	-3


LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		callBlock: 	[ self commit_lookup: self repo: self repository id: self id ]
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit>>lookup
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit(LGitObject)>>initializeWithId:
	Receiver: a LGitCommit (<not initialized>)
	Arguments and temporary variables: 
		gitOid: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')
	Receiver's instance variables: 
		handle: 	@ 16r00000000
		repository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-feat...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')


LGitCommit class(LGitObject class)>>of:fromId:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-fea...etc...
		id: 	a LGitId ('560d041efb101566775a516c29f690227fdaa558')
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInRepository:...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGitCommit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


LGitCommit class>>of:fromHexString:
	Receiver: LGitCommit
	Arguments and temporary variables: 
		aRepository: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-fea...etc...
		aCommitId: 	'560d041efb101566775a516c29f690227fdaa558'
	Receiver's instance variables: 
		superclass: 	LGitObject
		methodDict: 	a MethodDictionary(#=->LGitCommit>>#= #asIcebergObjectInRepository:...etc...
		format: 	65539
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#LGitCommit
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'LibGit-Core-CoreObjects'


[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ] in IceGitCommit>>libgitCommit
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


BlockClosure>>on:do:
	Receiver: [ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
	Arguments and temporary variables: 
		exception: 	LGitCallReturnHandler
		handlerAction: 	[ :error | error acceptError: (IceLibgitErrorVisitor onContext: ...etc...
	Receiver's instance variables: 
		outerContext: 	IceGitCommit>>libgitCommit
		startpc: 	38
		numArgs: 	0


IceLibgitRepository>>handleLibgitError:
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 
		aBlock: 	[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ]
	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	''
		commitCache: 	a LRUCache(#7 7/30 [ 1 ] 100%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


IceGitCommit>>libgitCommit
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>fileSystem
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


IceGitCommit>>DoItIn:
	Receiver: IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
	Arguments and temporary variables: 
		ThisContext: 	IceGitCommit>>fetchPackageNames
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packageCache: 	nil
		id: 	'560d041efb101566775a516c29f690227fdaa558'
		author: 	'QDucasse'
		datetime: 	2018-06-25T10:44:58+02:00
		ancestorIds: 	#('591afec537154f7cb0293d8778850ca63f0de4dc')
		comment: 	'chapterOneMethod'
		packageNamesCache: 	nil


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoItIn: ThisContext
	^ self fileSystem
		source: 	a ReadStream
		context: 	IceGitCommit>>fetchPackageNames
		receiver: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		ctxt: 	IceGitCommit>>fetchPackageNames
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(1035029504)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(1035029504)
		selectorChooser: 	nil
		notificationStrategy: 	a RubTextInsertionStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(12311040)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(1035029504)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1106@278)
		owner: 	a TransformWithLayoutMorph(50120704)
		submorphs: 	an Array(a RubCursor(260034560) a RubPrimarySelectionMorph(917734912...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (272163840) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(568846848)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(260034560)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(121253376))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoMethodRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(12311040)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(369390592))(a DropList...etc...
		lastStepTime: 	1369454
		lastStepMessage: 	nil
		lastCycleTime: 	1369470
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(260034560)))
		lastAlarmTime: 	1369454
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(369390592))(a DropList...etc...
		lastStepTime: 	1369454
		lastStepMessage: 	nil
		lastCycleTime: 	1369470
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(260034560)))
		lastAlarmTime: 	1369454
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(369390592))(a DropList...etc...
		lastStepTime: 	1369454
		lastStepMessage: 	nil
		lastCycleTime: 	1369470
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(260034560)))
		lastAlarmTime: 	1369454
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(62...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
IceLibgitErrorVisitor>>visitENOTFOUND:
LGit_GIT_ENOTFOUND>>acceptError:
[ :error | error acceptError: (IceLibgitErrorVisitor onContext: self) ] in IceLibgitRepository>>handleLibgitError:
BlockClosure>>cull:
Context>>evaluateSignal:
Context>>handleSignal:
LGit_GIT_ENOTFOUND(Exception)>>signal
LGit_GIT_ENOTFOUND class(LGitCallReturnHandler class)>>signalWith:
LGitReturnCodeEnum>>handleLGitReturnCode
LGitCommit(LGitExternalObject)>>withReturnHandlerDo:
LGitCommit>>lookup
LGitCommit(LGitObject)>>initializeWithId:
LGitCommit class(LGitObject class)>>of:fromId:
LGitCommit class>>of:fromHexString:
[ ^ LGitCommit of: self repositoryHandle fromHexString: self id ] in IceGitCommit>>libgitCommit
BlockClosure>>on:do:
IceLibgitRepository>>handleLibgitError:
IceGitCommit>>libgitCommit
IceGitCommit>>fileSystem
IceGitCommit>>DoItIn:
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoMethodRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of IceLibgitRepository did not understand #fileSystem
26 June 2018 5:23:57.548502 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

IceLibgitRepository(Object)>>doesNotUnderstand: #fileSystem
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 
		aMessage: 	fileSystem
		exception: 	MessageNotUnderstood: IceLibgitRepository>>fileSystem
		resumeValue: 	nil
	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	'src'
		commitCache: 	a LRUCache(#1 1/30 [ 1 ] 97%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


IceLibgitRepository>>DoIt
	Receiver: IceLibgitRepository(MetacelloTestBook-Code)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		name: 	'MetacelloTestBook-Code'
		workingCopy: 	an IceWorkingCopy
		index: 	an IceGitIndex
		location: 	File @ /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloB...etc...
		subdirectory: 	'src'
		commitCache: 	a LRUCache(#1 1/30 [ 1 ] 97%)
		handle: 	a LGitRepository (/Users/quentin/Documents/Pharo/images/Pillar-featureM...etc...


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ self fileSystem
		source: 	a ReadStream
		context: 	nil
		receiver: 	IceLibgitRepository(MetacelloTestBook-Code)
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	IceLibgitRepository(MetacelloTestBook-Code)
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(982791168)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | result inspect ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(982791168)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(332848128)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(982791168)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1217@50)
		owner: 	a TransformWithLayoutMorph(404446720)
		submorphs: 	an Array(a RubPrimarySelectionMorph(965157376) a RubCursor(386048000...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (761172992) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(750814720)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color black
		margins: 	a Margin top: 6 left: 6 bottom: 6 right: 6
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(386048000)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(478150144))
		getMenuPolicy: 	nil
		mouseDownPoint: 	(233.0@135.0)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(332848128)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(369390592))(a DropList...etc...
		lastStepTime: 	1386335
		lastStepMessage: 	nil
		lastCycleTime: 	1386355
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(386048000)))
		lastAlarmTime: 	1386335
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(369390592))(a DropList...etc...
		lastStepTime: 	1386335
		lastStepMessage: 	nil
		lastCycleTime: 	1386355
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(386048000)))
		lastAlarmTime: 	1386335
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(369390592))(a DropList...etc...
		lastStepTime: 	1386335
		lastStepMessage: 	nil
		lastCycleTime: 	1386355
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(386048000)))
		lastAlarmTime: 	1386335
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(62...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
IceLibgitRepository(Object)>>doesNotUnderstand: #fileSystem
IceLibgitRepository>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of IceWorkingCopy did not understand #head
26 June 2018 5:26:22.821755 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

IceWorkingCopy(Object)>>doesNotUnderstand: #head
	Receiver: an IceWorkingCopy
	Arguments and temporary variables: 
		aMessage: 	head
		exception: 	MessageNotUnderstood: IceWorkingCopy>>head
		resumeValue: 	nil
	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packages: 	a Dictionary()
		referenceCommit: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		shouldIgnoreNotifications: 	false


IceWorkingCopy>>DoIt
	Receiver: an IceWorkingCopy
	Arguments and temporary variables: 

	Receiver's instance variables: 
		repository: 	IceLibgitRepository(MetacelloTestBook-Code)
		packages: 	a Dictionary()
		referenceCommit: 	IceGitCommit(560d041efb101566775a516c29f690227fdaa558)
		shouldIgnoreNotifications: 	false


OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ self head
		source: 	a ReadStream
		context: 	nil
		receiver: 	an IceWorkingCopy
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	an IceWorkingCopy
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(1042295808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	nil
		textArea: 	a RubEditingArea(1042295808)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(915968)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	1531595
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	1531629
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	1531595
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	1531629
		pending: 	a Heap()
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(798931456))(a DropList...etc...
		lastStepTime: 	1531593
		lastStepMessage: 	nil
		lastCycleTime: 	1531627
		alarms: 	a Heap()
		lastAlarmTime: 	1531593
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		now: 	1531629
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(798931456))(a DropList...etc...
		lastStepTime: 	1531593
		lastStepMessage: 	nil
		lastCycleTime: 	1531627
		alarms: 	a Heap()
		lastAlarmTime: 	1531593
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(798931456))(a DropList...etc...
		lastStepTime: 	1531593
		lastStepMessage: 	nil
		lastCycleTime: 	1531627
		alarms: 	a Heap()
		lastAlarmTime: 	1531593
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(798931456))(a DropList...etc...
		lastStepTime: 	1531593
		lastStepMessage: 	nil
		lastCycleTime: 	1531627
		alarms: 	a Heap()
		lastAlarmTime: 	1531593
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(798931456))(a DropList...etc...
		lastStepTime: 	1531593
		lastStepMessage: 	nil
		lastCycleTime: 	1531627
		alarms: 	a Heap()
		lastAlarmTime: 	1531593
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(62...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
IceWorkingCopy(Object)>>doesNotUnderstand: #head
IceWorkingCopy>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[master]
26 June 2018 5:29:40.858485 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucass...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	a MCWorkingCopy(BaselineOfMetacelloTestBook)
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	a Dictionary('baseline'->baseline [BaselineOfMetacelloTestBook] )
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	#linear
		configuration: 	a BaselineOfMetacelloTestBook
		projectAttributes: 	#()
		versionNumberClass: 	MetacelloVersionNumber


MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	a Dictionary('baseline'->baseline [BaselineOfMetacelloTestBook] )
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	#linear
		configuration: 	a BaselineOfMetacelloTestBook
		projectAttributes: 	#()
		versionNumberClass: 	MetacelloVersionNumber


MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestBook-Code/s...etc...
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		prj: 	BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/M...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#baselineArg:->#('MetacelloTestBook') #reposit...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code/src'


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code/src'


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Could not resolve: BaselineOfMetacelloTestBook [BaselineOfMetacelloTestBook] in /Users/quentin/Documents/Pharo/images/Pillar-featureMetacelloBookTester/pharo-local/package-cache git@github.com:QDucasse/MetacelloTestBook-Code.git[master]
26 June 2018 5:30:28.41093 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		references: 	#()
		repositoryError: 	nil
		retryCount: 	3
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
		cachedReference: 	nil
		mcVersion: 	nil
		references: 	nil
		nearestReference: 	nil
		externalReference: 	nil
		loadedVersionInfos: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
	Receiver: an IceMetacelloPharoPlatform
	Arguments and temporary variables: 
		aBlock: 	[ | references nearestReference cachedReference externalReference mcVer...etc...
		aString: 	'Fetching BaselineOfMetacelloTestBook'
	Receiver's instance variables: 
		bypassProgressBars: 	false
		bypassGoferLoadUpdateCategories: 	false


MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github:/...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>loadUsing:gofer:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
		pkg: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucass...etc...
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :pkg | pkg loadUsing: self gofer: gofer ]
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/Metac...etc...

MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		gofer: 	a MetacelloGofer
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


BlockClosure>>ensure:
	Receiver: [ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ]
	Arguments and temporary variables: 
		aBlock: 	[ loadDirective := oldRoot ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositor...etc...
		startpc: 	37
		numArgs: 	0


MetacelloLoaderPolicy>>pushLoadDirective:during:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aLoaderDirective: 	explicit load : BaselineOfMetacelloTestBook
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		oldRoot: 	linear load : 
	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
	Receiver: a MetacelloLoaderPolicy
	Arguments and temporary variables: 
		aBlock: 	[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositori...etc...
		aLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTes...etc...
		directive: 	explicit load : BaselineOfMetacelloTestBook
	Receiver's instance variables: 
		overrideRepositories: 	nil
		repositoryMap: 	a Dictionary()
		ensuredMap: 	a Dictionary()
		cacheRepository: 	a MCDictionaryRepository(cache)
		cacheGofer: 	a Gofer
		ignoreImage: 	false
		loadData: 	nil
		loadDirective: 	explicit load : BaselineOfMetacelloTestBook
		silently: 	nil


MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
	Receiver: a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfMetacelloTestBook)
	Arguments and temporary variables: 
		packageSpecs: 	an Array(spec 
	name: 'BaselineOfMetacelloTestBook';
	repository:...etc...
		repositories: 	an OrderedCollection(an IceMetacelloRepositoryAdapter)
		directive: 	nil
	Receiver's instance variables: 
		spec: 	spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucas...etc...
		operator: 	nil
		loaderPolicy: 	a MetacelloLoaderPolicy
		disablePackageCache: 	false


MetacelloPackageSpec>>explicitLoadUsing:
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 
		mcLoader: 	a MetacelloLoadingMCSpecLoader
		wc: 	a MCWorkingCopy(BaselineOfMetacelloTestBook)
		fetchingSpecLoader: 	a MetacelloFetchingMCSpecLoader(explicit load : BaselineOfM...etc...
	Receiver's instance variables: 
		project: 	<<error during printing>>

MetacelloPackageSpec>>load
	Receiver: spec 
	name: 'BaselineOfMetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestB...etc...
	Arguments and temporary variables: 

	Receiver's instance variables: 
		project: 	<<error during printing>>

[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ spec projectPackage load ]
	Arguments and temporary variables: 
		exception: 	MetacelloIgnorePackageLoaded
		handlerAction: 	[ :ex | "see https://github.com/dalehenrich/metacello-work/issue...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>getBaselineUnconditionalLoad:
		startpc: 	91
		numArgs: 	0


MetacelloScriptEngine>>getBaselineUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		spec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/Metacel...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		unconditionalLoad: 	true
		project: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
	Receiver: BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		aBool: 	false
	Receiver's instance variables: 
		versionMap: 	a Dictionary('baseline'->baseline [BaselineOfMetacelloTestBook] )
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	#linear
		configuration: 	a BaselineOfMetacelloTestBook
		projectAttributes: 	#()
		versionNumberClass: 	MetacelloVersionNumber


MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
	Receiver: BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		versionMap: 	a Dictionary('baseline'->baseline [BaselineOfMetacelloTestBook] )
		symbolicVersionMap: 	nil
		errorMap: 	nil
		loader: 	nil
		loaderClass: 	MetacelloLoadingMCSpecLoader
		loadType: 	#linear
		configuration: 	a BaselineOfMetacelloTestBook
		projectAttributes: 	#()
		versionNumberClass: 	MetacelloVersionNumber


MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
	Receiver: spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/MetacelloTestBook-Code/s...etc...
	Arguments and temporary variables: 
		aMetacelloScriptEngine: 	a MetacelloScriptEngine
		prj: 	BaselineOfMetacelloTestBook(baseline [BaselineOfMetacelloTestBook], )
	Receiver's instance variables: 
		project: 	<<error during printing>>

[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		loadedSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/M...etc...
		version: 	nil
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self loo...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "lookup and registration handlers need to be innermost s...etc...
	Receiver's instance variables: 
		outerContext: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		...etc...
		startpc: 	129
		numArgs: 	0


[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, M...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | "option handlers need to be outermost set of handlers .....etc...
	Receiver's instance variables: 
		outerContext: 	[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLook...etc...
		startpc: 	84
		numArgs: 	0


[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			,...etc...
	Arguments and temporary variables: 
		exception: 	MetacelloAllowLockedProjectChange
		handlerAction: 	[ :ex | "MetacelloAllowLockedProjectChange need to be outermost ...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLo...etc...
		startpc: 	79
		numArgs: 	0


[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>on:do:
	Receiver: [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
		...etc...
	Arguments and temporary variables: 
		exception: 	Warning
		handlerAction: 	[ :ex | "Warning is absolute outermost handler" self handleWarni...etc...
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>handleNotificationsForAction:
		startpc: 	74
		numArgs: 	0


MetacelloScriptEngine>>handleNotificationsForAction:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		actionBlock: 	[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[...etc...
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


BlockClosure>>ensure:
	Receiver: [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValida...etc...
	Arguments and temporary variables: 
		aBlock: 	[ "install old version of registry"
newRegistry := self registry.	"see ...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
		startpc: 	121
		numArgs: 	0


MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
	Receiver: MetacelloProjectRegistration
	Arguments and temporary variables: 
		newRegistry: 	a MetacelloProjectRegistry
		aBlock: 	[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self s...etc...
		oldRegistry: 	a MetacelloProjectRegistry
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#=->MetacelloProjectRegistration>>#= #baseName->...etc...
		format: 	65543
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#MetacelloProjectRegistration
		classPool: 	a Dictionary(#Registry->a MetacelloProjectRegistry )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Metacello-Core-Scripts'


MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
		onDownGradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
		onUpgradeBlock: 	[ :ex :existing :new | ex allowEvenIfLocked ]
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


MetacelloScriptEngine>>load:
	Receiver: a MetacelloScriptEngine
	Arguments and temporary variables: 
		required: 	#('Pillar-MetacelloTestBook')
	Receiver's instance variables: 
		root: 	nil
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...


[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		statements: 	an OrderedCollection(#baselineArg:->#('MetacelloTestBook') #reposit...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';
	repository: 'github://QDucasse/...etc...
		engine: 	a MetacelloScriptEngine
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code/src'


[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
	Receiver: a MetacelloScriptApiExecutor
	Arguments and temporary variables: 
		aString: 	'MetacelloTestBook'
		projectSpecBlock: 	[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine ...etc...
		projectSpec: 	spec 
	name: 'MetacelloTestBook';.
	Receiver's instance variables: 
		options: 	a Dictionary(#onConflict->[ :ex | ex useIncoming ] #onUpgrade->[ :ex |...etc...
		roots: 	nil
		singleRoot: 	true
		projectSpecGenerator: 	a MetacelloBaselineSpecGenerator
		actionArg: 	#load:->#(#('Pillar-MetacelloTestBook'))
		configurationArg: 	nil
		baselineArg: 	'MetacelloTestBook'
		projectArg: 	nil
		classNameArg: 	nil
		versionArg: 	nil
		repositoryArg: 	'github://QDucasse/MetacelloTestBook-Code/src'


Array(SequenceableCollection)>>do:
	Receiver: an Array(spec 
	name: 'MetacelloTestBook';.)
	Arguments and temporary variables: 
		aBlock: 	[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (...etc...
		index: 	1
	Receiver's instance variables: 
an Array(spec 
	name: 'MetacelloTestBook';.)


--- The full stack ---
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>retryingResolvePackageSpecReferences:gofer:
[ | references nearestReference cachedReference externalReference mcVersion loadedVersionInfos |
cachedReference := nil.
packageSpec
	searchCacheRepositoryForPackage: [ "check to see if mcz file is already in cacheRepository"
		cachedReference := self
			resolvePackageSpec: packageSpec
			cachedGofer: self loaderPolicy cacheGofer.
		(cachedReference ~~ nil and: [ packageSpec getFile ~~ nil ])
			ifTrue: [ cachedReference name = packageSpec file
					ifTrue:
						[ "exact match between packageSpec file and cache" ^ self scheduleFetchFor: packageSpec cachedReference: cachedReference ] ] ].
references := self
	retryingResolvePackageSpecReferences: packageSpec
	gofer: gofer.	"look up mcz file"
nearestReference := references last
	asMetacelloCachingResolvedReference.
(cachedReference ~~ nil
	and: [ cachedReference name = nearestReference name ])
	ifTrue: [ "latest reference in repository matches cachedReference ... "
		^ self
			scheduleFetchFor: packageSpec
			nearestReference: nearestReference ].
(self ignoreImage not
	and: [ (loadedVersionInfos := self ancestorsFor: packageSpec) ~~ nil ])
	ifTrue: [ "If the mcz is already loaded into the image, no need to copy"
		loadedVersionInfos
			do: [ :info | 
				info name = nearestReference name
					ifTrue: [ | spc |
						spc := packageSpec copy.
						spc file: info name.
						(MetacelloIgnorePackageLoaded signal: spc)
							ifFalse: [ ^ self ] ] ] ].
externalReference := (references
	select: [ :ref | ref name = nearestReference name ]) first
	asMetacelloCachingResolvedReference.
self repositoryMap
	at: externalReference name
	put: externalReference repository.
(self
	resolveDependencies: externalReference
	nearest: nearestReference
	into: (OrderedCollection with: nearestReference))
	do: [ :reference | 
		| pSpec l |
		mcVersion := reference version.
		(l := (GoferVersionReference name: reference name)
			resolveAllWith: self loaderPolicy cacheGofer) isEmpty
			ifTrue: [ self cacheRepository storeVersion: mcVersion.
				reference == nearestReference
					ifTrue: [ pSpec := packageSpec ]
					ifFalse: [ pSpec := packageSpec project packageSpec.
						pSpec name: mcVersion package name ].
				self loadData
					addVersion: mcVersion
					versionInfo: mcVersion info
					resolvedReference: reference
					packageSpec: pSpec ] ].
self
	scheduleFetchFor: packageSpec
	externalReference: externalReference ] in MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
IceMetacelloPharoPlatform(MetacelloPlatform)>>do:displaying:
MetacelloFetchingMCSpecLoader>>linearLoadPackageSpec:gofer:
MetacelloPackageSpec>>loadUsing:gofer:
[ :pkg | pkg loadUsing: self gofer: gofer ] in MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
Array(SequenceableCollection)>>do:
MetacelloFetchingMCSpecLoader(MetacelloCommonMCSpecLoader)>>linearLoadPackageSpecs:repositories:
[ super
	linearLoadPackageSpecs: packageSpecs
	repositories: repositories ] in MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
BlockClosure>>ensure:
MetacelloLoaderPolicy>>pushLoadDirective:during:
MetacelloLoaderPolicy>>pushExplicitLoadDirectivesDuring:for:
MetacelloFetchingMCSpecLoader>>explicitLoadPackageSpecs:repositories:
MetacelloPackageSpec>>explicitLoadUsing:
MetacelloPackageSpec>>load
[ spec projectPackage load ] in MetacelloScriptEngine>>getBaselineUnconditionalLoad:
BlockClosure>>on:do:
MetacelloScriptEngine>>getBaselineUnconditionalLoad:
MetacelloScriptEngine>>getBaselineProjectUnconditionalLoad:
MetacelloMCBaselineProject>>projectForScriptEngine:unconditionalLoad:
MetacelloMCBaselineProject(MetacelloProject)>>projectForScriptEngine:
MetacelloMCBaselineOfProjectSpec(MetacelloMCProjectSpec)>>versionForScriptEngine:
[ | version loadedSpec |
self setDefaultsAndValidateProjectSpec.
[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
	on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
	do:
		[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
version := loadedSpec versionForScriptEngine: self.
self
	root:
		(required isEmpty
			ifTrue: [ version load ]
			ifFalse: [ version load: required ]) loadDirective.
loadedSpec loads: required.
MetacelloProjectRegistration
	registrationForProjectSpec: loadedSpec
	ifAbsent: [ :new | 
		new
			loadedInImage: true;
			registerProject ]
	ifPresent: [ :existing :new | 
		existing
			copyOnWrite: [ :existingCopy | 
				existingCopy
					loadedInImage: true;
					merge: new ] ] ] in [ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>on:do:
[ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ] in [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ] in [ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
[ [ [ actionBlock
	on:
		MetacelloLookupProjectSpec , MetacelloLookupProjectSpecForLoad
			, MetacelloProjectSpecLoadedNotification
			, MetacelloScriptEnsureProjectLoadedForDevelopment
			, MetacelloLookupBaselineSpecForEnsureLoad
	do:
		[ :ex | "lookup and registration handlers need to be innermost set of handlers ...they may throw option notifications" ex handleResolutionFor: self ] ]
	on:
		MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			, MetacelloAllowConflictingProjectUpgrade
	do:
		[ :ex | "option handlers need to be outermost set of handlers ... last line of defense before users are involved" ex handleResolutionFor: self ] ]
	on: MetacelloAllowLockedProjectChange
	do:
		[ :ex | "MetacelloAllowLockedProjectChange need to be outermost handler ... since it is signaled from second line of handlers" ex handleResolutionFor: self ] ] in MetacelloScriptEngine>>handleNotificationsForAction:
BlockClosure>>on:do:
MetacelloScriptEngine>>handleNotificationsForAction:
[ self
	handleNotificationsForAction: [ | version loadedSpec |
		self setDefaultsAndValidateProjectSpec.
		[ loadedSpec := (self lookupProjectSpecFor: self projectSpec) copy ]
			on: MetacelloAllowProjectDowngrade , MetacelloAllowProjectUpgrade
			do:
				[ :ex | ex handleOnDownGrade: onDownGradeBlock onUpgrade: onUpgradeBlock ].
		version := loadedSpec versionForScriptEngine: self.
		self
			root:
				(required isEmpty
					ifTrue: [ version load ]
					ifFalse: [ version load: required ]) loadDirective.
		loadedSpec loads: required.
		MetacelloProjectRegistration
			registrationForProjectSpec: loadedSpec
			ifAbsent: [ :new | 
				new
					loadedInImage: true;
					registerProject ]
			ifPresent: [ :existing :new | 
				existing
					copyOnWrite: [ :existingCopy | 
						existingCopy
							loadedInImage: true;
							merge: new ] ] ] ] in MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
BlockClosure>>ensure:
MetacelloProjectRegistration class>>copyRegistryRestoreOnErrorWhile:
MetacelloScriptEngine>>load:onProjectDownGrade:onProjectUpgrade:
MetacelloScriptEngine>>load:
[ :projectSpec | 
| engine |
engine := MetacelloScriptEngine new
	options: self options copy;
	projectSpec: projectSpec;
	yourself.
engine perform: actionArg key withArguments: actionArg value.
engine root ifNotNil: [ :root | self roots add: root ] ] in MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
[ :projectSpec | 
projectSpec
	ifNotNil: [ projectSpecBlock
			value: (self applyArgsToProjectSpec: projectSpec copy) ] ] in MetacelloScriptApiExecutor>>executeString:do:
Array(SequenceableCollection)>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
MetacelloScriptApiExecutor>>executeString:do:
ByteString(String)>>execute:against:
MetacelloScriptApiExecutor(MetacelloScriptExecutor)>>execute:
Metacello>>execute:args:
Metacello>>load:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #isByteString
26 June 2018 5:34:43.686728 pm

VM: Mac OS - intel - 1011.6 - CoInterpreter VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
StackToRegisterMappingCogit VMMaker.oscog-eem.2380 uuid: c76d37e1-445c-4e34-9796-fc836dfd50c9 May  9 2018
VM: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git Date: Wed May 9 10:36:12 2018 CommitHash: 334be97 Plugins: 201805090836 https://github.com/OpenSmalltalk/opensmalltalk-vm.git

Image: Pharo7.0alpha [Build information: Pharo-7.0+alpha.build.1081.sha.ddb681a635f9442dc597ec6d83a3fea436db9f73 (32 Bit)]

SmallInteger(Object)>>doesNotUnderstand: #isByteString
	Receiver: 1
	Arguments and temporary variables: 
		aMessage: 	isByteString
		exception: 	MessageNotUnderstood: SmallInteger>>isByteString
		resumeValue: 	nil
	Receiver's instance variables: 
1

ByteString(String)>>compare:with:collated:
	Receiver: 'MetacelloTestBook-Code'
	Arguments and temporary variables: 
		string1: 	'MetacelloTestBook-Code'
		string2: 	1
		order: 	#[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26...etc...
	Receiver's instance variables: 
'MetacelloTestBook-Code'

ByteString(String)>><
	Receiver: 'MetacelloTestBook-Code'
	Arguments and temporary variables: 
		aString: 	1
	Receiver's instance variables: 
'MetacelloTestBook-Code'

OrderedCollection>>at:
	Receiver: an OrderedCollection(IceLibgitRepository(iceberg) IceLibgitRepository(pharo) IceLibgitRepo...etc...
	Arguments and temporary variables: 
		anInteger: 	'MetacelloTestBook-Code'
		index: 	nil
	Receiver's instance variables: 
		array: 	an Array(IceLibgitRepository(iceberg) IceLibgitRepository(pharo) IceLibg...etc...
		firstIndex: 	1
		lastIndex: 	9


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ IceLibgitRepository registry at: 'MetacelloTestBook-Code'
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901707264)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | 
textMorph shoutStyler style: textMorph text.
GLMPrintPoppe...etc...
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(901707264)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(311648256)
		textModel: 	a GLMRubricSmalltalkTextModel


MorphicAlarm(MessageSend)>>value
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	2032482
		numArgs: 	0


MorphicAlarm>>value:
	Receiver: MorphicAlarm(#popupPrint -> a GLMMorphicPharoScriptRenderer)
	Arguments and temporary variables: 
		anArgument: 	2032494
		nArgs: 	0
	Receiver's instance variables: 
		receiver: 	a GLMMorphicPharoScriptRenderer
		selector: 	#popupPrint
		arguments: 	#()
		scheduledTime: 	2032482
		numArgs: 	0


WorldState>>triggerAlarmsBefore:
	Receiver: a WorldState
	Arguments and temporary variables: 
		nowTime: 	2032494
		pending: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(918089728)))
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(263137792))(a SearchMorp...etc...
		lastStepTime: 	2032474
		lastStepMessage: 	nil
		lastCycleTime: 	2032494
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(918089728)))
		lastAlarmTime: 	2032474
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runLocalStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		now: 	2032494
		morphToStep: 	nil
		stepTime: 	nil
		priorWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(263137792))(a SearchMorp...etc...
		lastStepTime: 	2032474
		lastStepMessage: 	nil
		lastCycleTime: 	2032494
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(918089728)))
		lastAlarmTime: 	2032474
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	nil
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(263137792))(a SearchMorp...etc...
		lastStepTime: 	2032474
		lastStepMessage: 	nil
		lastCycleTime: 	2032494
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(918089728)))
		lastAlarmTime: 	2032474
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(263137792))(a SearchMorp...etc...
		lastStepTime: 	2032474
		lastStepMessage: 	nil
		lastCycleTime: 	2032494
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(918089728)))
		lastAlarmTime: 	2032474
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(629803520) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(565529600))
		viewBox: 	(0@0) corner: (1688@1129)
		canvas: 	a FormCanvas on: DisplayScreen(1688x1129x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(263137792))(a SearchMorp...etc...
		lastStepTime: 	2032474
		lastStepMessage: 	nil
		lastCycleTime: 	2032494
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(918089728)))
		lastAlarmTime: 	2032474
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(565529600)
		currentCursor: 	((CursorWithMask
	extent: (16@16)
	depth: 1
	fromArray: #(
		2r0...etc...


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(629803520) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1688@1129)
		owner: 	nil
		submorphs: 	an Array(a MenubarMorph(613249536) a TaskbarMorph(763158016) a GLMSy...etc...
		fullBounds: 	(0@0) corner: (1688@1129)
		color: 	(Color r: 0.9400000000000001 g: 0.9400000000000001 b: 0.9400000000000001...etc...
		extension: 	a MorphExtension (112123136) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#AllowDropFiles->nil #CursorOwnerWorld->a WorldMorph(62...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		announcer: 	nil
		displayScaleFactor: 	1


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #isByteString
ByteString(String)>>compare:with:collated:
ByteString(String)>><
OrderedCollection>>at:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>popupPrint
MorphicAlarm(MessageSend)>>value
MorphicAlarm>>value:
WorldState>>triggerAlarmsBefore:
WorldState>>runLocalStepMethodsIn:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

